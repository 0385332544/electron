From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Simon Hangl <simonha@google.com>
Date: Wed, 25 May 2022 10:25:19 +0000
Subject: =?UTF-8?q?[MSC]=20Partial=20extension=20getDisplayMedia=20interna?=
 =?UTF-8?q?ls=20to=20return=0Astream=20vectors.?=

The getDisplayMedia implementation currently only handles single
streams. This CL is a first step to port this implementation to
handle stream vectors and ports UserMediaProcessor and directly
related interfaces / clients.

Bug: 1300883
Change-Id: Id547b88af42bcef90bd3d4f198912cb774288ea7
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/3557211
Reviewed-by: Daniel Cheng <dcheng@chromium.org>
Reviewed-by: Evan Liu <evliu@google.com>
Reviewed-by: Elad Alon <eladalon@chromium.org>
Commit-Queue: Simon Hangl <simonha@google.com>
Cr-Commit-Position: refs/heads/main@{#1007320}

diff --git a/content/browser/renderer_host/media/media_stream_dispatcher_host.cc b/content/browser/renderer_host/media/media_stream_dispatcher_host.cc
index e8d31bee36c528fe86df638480dda0a6d03ffde2..dff26442762a67334966632ae3ef75efa56d4096 100644
--- a/content/browser/renderer_host/media/media_stream_dispatcher_host.cc
+++ b/content/browser/renderer_host/media/media_stream_dispatcher_host.cc
@@ -170,7 +170,7 @@ struct MediaStreamDispatcherHost::PendingAccessRequest {
       const blink::StreamControls& controls,
       bool user_gesture,
       blink::mojom::StreamSelectionInfoPtr audio_stream_selection_info_ptr,
-      GenerateStreamCallback callback,
+      GenerateStreamsCallback callback,
       MediaDeviceSaltAndOrigin salt_and_origin)
       : page_request_id(page_request_id),
         controls(controls),
@@ -185,7 +185,7 @@ struct MediaStreamDispatcherHost::PendingAccessRequest {
   const blink::StreamControls controls;
   bool user_gesture;
   blink::mojom::StreamSelectionInfoPtr audio_stream_selection_info_ptr;
-  GenerateStreamCallback callback;
+  GenerateStreamsCallback callback;
   MediaDeviceSaltAndOrigin salt_and_origin;
 };
 
@@ -284,7 +284,7 @@ void MediaStreamDispatcherHost::OnWebContentsFocused() {
   while (!pending_requests_.empty()) {
     std::unique_ptr<PendingAccessRequest> request =
         std::move(pending_requests_.front());
-    media_stream_manager_->GenerateStream(
+    media_stream_manager_->GenerateStreams(
         render_process_id_, render_frame_id_, requester_id_,
         request->page_request_id, request->controls,
         std::move(request->salt_and_origin), request->user_gesture,
@@ -335,7 +335,8 @@ void MediaStreamDispatcherHost::CancelAllRequests() {
   for (auto& pending_request : pending_requests_) {
     std::move(pending_request->callback)
         .Run(blink::mojom::MediaStreamRequestResult::FAILED_DUE_TO_SHUTDOWN,
-             /*label=*/std::string(), /*stream_devices=*/nullptr,
+             /*label=*/std::string(),
+             /*stream_devices_set=*/nullptr,
              /*pan_tilt_zoom_allowed=*/false);
   }
   pending_requests_.clear();
@@ -343,12 +344,12 @@ void MediaStreamDispatcherHost::CancelAllRequests() {
                                            requester_id_);
 }
 
-void MediaStreamDispatcherHost::GenerateStream(
+void MediaStreamDispatcherHost::GenerateStreams(
     int32_t page_request_id,
     const blink::StreamControls& controls,
     bool user_gesture,
     blink::mojom::StreamSelectionInfoPtr audio_stream_selection_info_ptr,
-    GenerateStreamCallback callback) {
+    GenerateStreamsCallback callback) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
   if (!AllowedStreamTypeCombination(controls.audio.stream_type,
@@ -371,18 +372,18 @@ void MediaStreamDispatcherHost::GenerateStream(
       GetUIThreadTaskRunner({}).get(), FROM_HERE,
       base::BindOnce(salt_and_origin_callback_, render_process_id_,
                      render_frame_id_),
-      base::BindOnce(&MediaStreamDispatcherHost::DoGenerateStream,
+      base::BindOnce(&MediaStreamDispatcherHost::DoGenerateStreams,
                      weak_factory_.GetWeakPtr(), page_request_id, controls,
                      user_gesture, std::move(audio_stream_selection_info_ptr),
                      std::move(callback)));
 }
 
-void MediaStreamDispatcherHost::DoGenerateStream(
+void MediaStreamDispatcherHost::DoGenerateStreams(
     int32_t page_request_id,
     const blink::StreamControls& controls,
     bool user_gesture,
     blink::mojom::StreamSelectionInfoPtr audio_stream_selection_info_ptr,
-    GenerateStreamCallback callback,
+    GenerateStreamsCallback callback,
     MediaDeviceSaltAndOrigin salt_and_origin) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
@@ -390,7 +391,8 @@ void MediaStreamDispatcherHost::DoGenerateStream(
                                            salt_and_origin.origin)) {
     std::move(callback).Run(
         blink::mojom::MediaStreamRequestResult::INVALID_SECURITY_ORIGIN,
-        /*label=*/std::string(), /*stream_devices=*/nullptr,
+        /*label=*/std::string(),
+        /*stream_devices_set=*/nullptr,
         /*pan_tilt_zoom_allowed=*/false);
     return;
   }
@@ -413,7 +415,7 @@ void MediaStreamDispatcherHost::DoGenerateStream(
     return;
   }
 
-  media_stream_manager_->GenerateStream(
+  media_stream_manager_->GenerateStreams(
       render_process_id_, render_frame_id_, requester_id_, page_request_id,
       controls, std::move(salt_and_origin), user_gesture,
       std::move(audio_stream_selection_info_ptr), std::move(callback),
diff --git a/content/browser/renderer_host/media/media_stream_dispatcher_host.h b/content/browser/renderer_host/media/media_stream_dispatcher_host.h
index 00162c965093655fa4aa15df90dcb80ca45534b0..67f7bedcd4d8019c32c84898ef026f07a618bf2d 100644
--- a/content/browser/renderer_host/media/media_stream_dispatcher_host.h
+++ b/content/browser/renderer_host/media/media_stream_dispatcher_host.h
@@ -74,12 +74,12 @@ class CONTENT_EXPORT MediaStreamDispatcherHost
   void CancelAllRequests();
 
   // mojom::MediaStreamDispatcherHost implementation
-  void GenerateStream(
+  void GenerateStreams(
       int32_t request_id,
       const blink::StreamControls& controls,
       bool user_gesture,
       blink::mojom::StreamSelectionInfoPtr audio_stream_selection_info_ptr,
-      GenerateStreamCallback callback) override;
+      GenerateStreamsCallback callback) override;
   void CancelRequest(int32_t request_id) override;
   void StopStreamDevice(
       const std::string& device_id,
@@ -114,12 +114,12 @@ class CONTENT_EXPORT MediaStreamDispatcherHost
                        const base::UnguessableToken& session_id,
                        GetOpenDeviceCallback callback,
                        MediaDeviceSaltAndOrigin salt_and_origin);
-  void DoGenerateStream(
+  void DoGenerateStreams(
       int32_t request_id,
       const blink::StreamControls& controls,
       bool user_gesture,
       blink::mojom::StreamSelectionInfoPtr audio_stream_selection_info_ptr,
-      GenerateStreamCallback callback,
+      GenerateStreamsCallback callback,
       MediaDeviceSaltAndOrigin salt_and_origin);
   void DoOpenDevice(int32_t request_id,
                     const std::string& device_id,
diff --git a/content/browser/renderer_host/media/media_stream_dispatcher_host_unittest.cc b/content/browser/renderer_host/media/media_stream_dispatcher_host_unittest.cc
index b1a8dcd0024f3ad15e055474ce038dd2cfe90ed3..08629d4f972a8b155fc56a2437fc78d181b4ebff 100644
--- a/content/browser/renderer_host/media/media_stream_dispatcher_host_unittest.cc
+++ b/content/browser/renderer_host/media/media_stream_dispatcher_host_unittest.cc
@@ -19,6 +19,7 @@
 #include "base/command_line.h"
 #include "base/containers/queue.h"
 #include "base/memory/raw_ptr.h"
+#include "base/ranges/algorithm.h"
 #include "base/run_loop.h"
 #include "base/system/system_monitor.h"
 #include "base/task/single_thread_task_runner.h"
@@ -45,6 +46,7 @@
 #include "mojo/public/cpp/bindings/receiver.h"
 #include "testing/gmock/include/gmock/gmock.h"
 #include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/public/common/mediastream/media_stream_request.h"
 #include "third_party/blink/public/mojom/mediastream/media_stream.mojom-shared.h"
 #include "third_party/blink/public/mojom/mediastream/media_stream.mojom.h"
 #include "url/gurl.h"
@@ -110,9 +112,9 @@ class MockMediaStreamDispatcherHost
   // Accessor to private functions.
   void CancelAllRequests() { MediaStreamDispatcherHost::CancelAllRequests(); }
 
-  void OnGenerateStream(int page_request_id,
-                        const blink::StreamControls& controls) {
-    MediaStreamDispatcherHost::GenerateStream(
+  void OnGenerateStreams(int page_request_id,
+                         const blink::StreamControls& controls) {
+    MediaStreamDispatcherHost::GenerateStreams(
         page_request_id, controls, false,
         blink::mojom::StreamSelectionInfo::New(
             blink::mojom::StreamSelectionStrategy::SEARCH_BY_DEVICE_ID,
@@ -120,16 +122,16 @@ class MockMediaStreamDispatcherHost
         base::DoNothing());
   }
 
-  void OnGenerateStream(int page_request_id,
-                        const blink::StreamControls& controls,
-                        base::OnceClosure quit_closure) {
+  void OnGenerateStreams(int page_request_id,
+                         const blink::StreamControls& controls,
+                         base::OnceClosure quit_closure) {
     quit_closures_.push(std::move(quit_closure));
-    MediaStreamDispatcherHost::GenerateStream(
+    MediaStreamDispatcherHost::GenerateStreams(
         page_request_id, controls, false,
         blink::mojom::StreamSelectionInfo::New(
             blink::mojom::StreamSelectionStrategy::SEARCH_BY_DEVICE_ID,
             absl::nullopt),
-        base::BindOnce(&MockMediaStreamDispatcherHost::OnStreamGenerated,
+        base::BindOnce(&MockMediaStreamDispatcherHost::OnStreamsGenerated,
                        base::Unretained(this), page_request_id));
   }
 
@@ -175,23 +177,37 @@ class MockMediaStreamDispatcherHost
   }
 
   std::string label_;
-  blink::mojom::StreamDevicesPtr devices_ = blink::mojom::StreamDevices::New();
+  blink::mojom::StreamDevicesSetPtr stream_devices_set_;
   blink::MediaStreamDevice opened_device_;
 
  private:
   // These handler methods do minimal things and delegate to the mock methods.
-  void OnStreamGenerated(int request_id,
-                         blink::mojom::MediaStreamRequestResult result,
-                         const std::string& label,
-                         blink::mojom::StreamDevicesPtr devices,
-                         bool pan_tilt_zoom_allowed) {
+  void OnStreamsGenerated(int request_id,
+                          blink::mojom::MediaStreamRequestResult result,
+                          const std::string& label,
+                          blink::mojom::StreamDevicesSetPtr stream_devices_set,
+                          bool pan_tilt_zoom_allowed) {
     if (result != blink::mojom::MediaStreamRequestResult::OK) {
+      DCHECK(!stream_devices_set);
       OnStreamGenerationFailed(request_id, result);
       return;
     }
 
-    OnStreamGenerationSuccess(request_id, devices->audio_device.has_value(),
-                              devices->video_device.has_value());
+    DCHECK(stream_devices_set);
+
+    size_t audio_devices_count = base::ranges::count_if(
+        stream_devices_set->stream_devices,
+        [](const blink::mojom::StreamDevicesPtr& devices) {
+          return devices->audio_device.has_value();
+        });
+    size_t video_devices_count = base::ranges::count_if(
+        stream_devices_set->stream_devices,
+        [](const blink::mojom::StreamDevicesPtr& devices) {
+          return devices->video_device.has_value();
+        });
+
+    OnStreamGenerationSuccess(request_id, audio_devices_count,
+                              video_devices_count);
     // Simulate the stream started event back to host for UI testing.
     OnStreamStarted(label);
 
@@ -200,7 +216,7 @@ class MockMediaStreamDispatcherHost
     quit_closures_.pop();
 
     label_ = label;
-    devices_ = std::move(devices);
+    stream_devices_set_ = std::move(stream_devices_set);
   }
 
   void OnStreamGenerationFailed(int request_id,
@@ -217,9 +233,11 @@ class MockMediaStreamDispatcherHost
   void OnDeviceStoppedInternal(const std::string& label,
                                const blink::MediaStreamDevice& device) {
     if (blink::IsVideoInputMediaType(device.type))
-      EXPECT_TRUE(device.IsSameDevice(devices_->video_device.value()));
+      EXPECT_TRUE(device.IsSameDevice(
+          stream_devices_set_->stream_devices[0]->video_device.value()));
     if (blink::IsAudioInputMediaType(device.type))
-      EXPECT_TRUE(device.IsSameDevice(devices_->audio_device.value()));
+      EXPECT_TRUE(device.IsSameDevice(
+          stream_devices_set_->stream_devices[0]->audio_device.value()));
 
     OnDeviceStopSuccess();
   }
@@ -379,14 +397,14 @@ class MediaStreamDispatcherHostTest : public testing::Test {
     EXPECT_CALL(*host_, OnStreamGenerationSuccess(page_request_id,
                                                   expected_audio_array_size,
                                                   expected_video_array_size));
-    host_->OnGenerateStream(page_request_id, controls, run_loop.QuitClosure());
+    host_->OnGenerateStreams(page_request_id, controls, run_loop.QuitClosure());
     run_loop.Run();
-    EXPECT_FALSE(DoesContainRawIds(host_->devices_->audio_device));
-    EXPECT_FALSE(DoesContainRawIds(host_->devices_->video_device));
+    EXPECT_FALSE(DoesContainRawIds(audio_device(/*stream_index=*/0u)));
+    EXPECT_FALSE(DoesContainRawIds(video_device(/*stream_index=*/0u)));
     EXPECT_TRUE(
-        DoesEveryDeviceMapToRawId(host_->devices_->audio_device, origin_));
+        DoesEveryDeviceMapToRawId(audio_device(/*stream_index=*/0u), origin_));
     EXPECT_TRUE(
-        DoesEveryDeviceMapToRawId(host_->devices_->video_device, origin_));
+        DoesEveryDeviceMapToRawId(video_device(/*stream_index=*/0u), origin_));
   }
 
   void GenerateStreamAndWaitForFailure(
@@ -396,7 +414,7 @@ class MediaStreamDispatcherHostTest : public testing::Test {
     base::RunLoop run_loop;
     EXPECT_CALL(*host_,
                 OnStreamGenerationFailure(page_request_id, expected_result));
-    host_->OnGenerateStream(page_request_id, controls, run_loop.QuitClosure());
+    host_->OnGenerateStreams(page_request_id, controls, run_loop.QuitClosure());
     run_loop.Run();
   }
 
@@ -408,9 +426,9 @@ class MediaStreamDispatcherHostTest : public testing::Test {
                         blink::mojom::MediaStreamType::DEVICE_VIDEO_CAPTURE,
                         run_loop.QuitClosure());
     run_loop.Run();
-    EXPECT_FALSE(DoesContainRawIds(host_->devices_->video_device.value()));
-    EXPECT_TRUE(DoesEveryDeviceMapToRawId(host_->devices_->video_device.value(),
-                                          origin_));
+    EXPECT_FALSE(DoesContainRawIds(video_device(/*stream_index=*/0u).value()));
+    EXPECT_TRUE(DoesEveryDeviceMapToRawId(
+        video_device(/*stream_index=*/0u).value(), origin_));
   }
 
   void OpenVideoDeviceAndWaitForFailure(int page_request_id,
@@ -421,9 +439,9 @@ class MediaStreamDispatcherHostTest : public testing::Test {
                         blink::mojom::MediaStreamType::DEVICE_VIDEO_CAPTURE,
                         run_loop.QuitClosure());
     run_loop.Run();
-    EXPECT_FALSE(DoesContainRawIds(host_->devices_->video_device.value()));
+    EXPECT_FALSE(DoesContainRawIds(video_device(/*stream_index=*/0u).value()));
     EXPECT_FALSE(DoesEveryDeviceMapToRawId(
-        host_->devices_->video_device.value(), origin_));
+        video_device(/*stream_index=*/0u).value(), origin_));
   }
 
   bool DoesContainRawIds(
@@ -478,6 +496,20 @@ class MediaStreamDispatcherHostTest : public testing::Test {
     host_->GetOpenDevice(request_id, session_id, std::move(callback));
   }
 
+  const absl::optional<blink::MediaStreamDevice>& audio_device(
+      size_t stream_index) const {
+    DCHECK_LT(stream_index, host_->stream_devices_set_->stream_devices.size());
+    return host_->stream_devices_set_->stream_devices[stream_index]
+        ->audio_device;
+  }
+
+  const absl::optional<blink::MediaStreamDevice>& video_device(
+      size_t stream_index) const {
+    DCHECK_LT(stream_index, host_->stream_devices_set_->stream_devices.size());
+    return host_->stream_devices_set_->stream_devices[stream_index]
+        ->video_device;
+  }
+
   base::test::ScopedFeatureList scoped_feature_list_;
   std::unique_ptr<MockMediaStreamDispatcherHost> host_;
   std::unique_ptr<MediaStreamManager> media_stream_manager_;
@@ -499,8 +531,8 @@ TEST_F(MediaStreamDispatcherHostTest, GenerateStreamWithVideoOnly) {
   SetupFakeUI(true);
   GenerateStreamAndWaitForResult(kPageRequestId, controls);
 
-  EXPECT_EQ(host_->devices_->audio_device, absl::nullopt);
-  EXPECT_NE(host_->devices_->video_device, absl::nullopt);
+  EXPECT_FALSE(audio_device(/*stream_index=*/0u).has_value());
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
 }
 
 TEST_F(MediaStreamDispatcherHostTest, GenerateStreamWithAudioOnly) {
@@ -509,8 +541,8 @@ TEST_F(MediaStreamDispatcherHostTest, GenerateStreamWithAudioOnly) {
   SetupFakeUI(true);
   GenerateStreamAndWaitForResult(kPageRequestId, controls);
 
-  EXPECT_NE(host_->devices_->audio_device, absl::nullopt);
-  EXPECT_EQ(host_->devices_->video_device, absl::nullopt);
+  EXPECT_TRUE(audio_device(/*stream_index=*/0u).has_value());
+  EXPECT_FALSE(video_device(/*stream_index=*/0u).has_value());
 }
 
 class MediaStreamDispatcherHostStreamTypeCombinationTest
@@ -552,7 +584,7 @@ TEST_P(MediaStreamDispatcherHostStreamTypeCombinationTest,
                  kProcessId, bad_message::MSDH_INVALID_STREAM_TYPE_COMBINATION))
       .Times(!kValidCombinations.count(std::make_tuple(
           controls.audio.stream_type, controls.video.stream_type)));
-  host_->OnGenerateStream(kPageRequestId, controls);
+  host_->OnGenerateStreams(kPageRequestId, controls);
 }
 
 INSTANTIATE_TEST_SUITE_P(
@@ -583,8 +615,8 @@ TEST_F(MediaStreamDispatcherHostTest, GenerateStreamWithAudioAndVideo) {
   SetupFakeUI(true);
   GenerateStreamAndWaitForResult(kPageRequestId, controls);
 
-  EXPECT_TRUE(host_->devices_->audio_device.has_value());
-  EXPECT_TRUE(host_->devices_->video_device.has_value());
+  EXPECT_TRUE(audio_device(/*stream_index=*/0u).has_value());
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
 }
 
 TEST_F(MediaStreamDispatcherHostTest, GenerateStreamWithDepthVideo) {
@@ -603,8 +635,8 @@ TEST_F(MediaStreamDispatcherHostTest, GenerateStreamWithDepthVideo) {
 
   // We specified the generation and expect to get
   // one audio and one depth video stream.
-  EXPECT_TRUE(host_->devices_->audio_device.has_value());
-  EXPECT_TRUE(host_->devices_->video_device.has_value());
+  EXPECT_TRUE(audio_device(/*stream_index=*/0u).has_value());
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
 }
 
 // This test generates two streams with video only using the same render frame
@@ -618,23 +650,27 @@ TEST_F(MediaStreamDispatcherHostTest, GenerateStreamsFromSameRenderId) {
   GenerateStreamAndWaitForResult(kPageRequestId, controls);
 
   // Check the latest generated stream.
-  EXPECT_EQ(host_->devices_->audio_device, absl::nullopt);
-  EXPECT_NE(host_->devices_->video_device, absl::nullopt);
+  EXPECT_FALSE(audio_device(/*stream_index=*/0u).has_value());
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
   const std::string label1 = host_->label_;
-  const std::string device_id1 = host_->devices_->video_device.value().id;
+  const std::string device_id1 = video_device(/*stream_index=*/0u).value().id;
   const base::UnguessableToken session_id1 =
-      host_->devices_->video_device.value().session_id();
+      host_->stream_devices_set_->stream_devices[0]
+          ->video_device.value()
+          .session_id();
 
   // Generate second stream.
   GenerateStreamAndWaitForResult(kPageRequestId + 1, controls);
 
   // Check the latest generated stream.
-  EXPECT_EQ(host_->devices_->audio_device, absl::nullopt);
-  EXPECT_NE(host_->devices_->video_device, absl::nullopt);
+  EXPECT_FALSE(audio_device(/*stream_index=*/0u).has_value());
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
   const std::string label2 = host_->label_;
-  const std::string device_id2 = host_->devices_->video_device.value().id;
+  const std::string device_id2 = video_device(/*stream_index=*/0u).value().id;
   const base::UnguessableToken session_id2 =
-      host_->devices_->video_device.value().session_id();
+      host_->stream_devices_set_->stream_devices[0]
+          ->video_device.value()
+          .session_id();
   EXPECT_EQ(device_id1, device_id2);
   EXPECT_EQ(session_id1, session_id2);
   EXPECT_NE(label1, label2);
@@ -648,12 +684,14 @@ TEST_F(MediaStreamDispatcherHostTest,
   // Generate first stream.
   GenerateStreamAndWaitForResult(kPageRequestId, controls);
 
-  EXPECT_EQ(host_->devices_->audio_device, absl::nullopt);
-  EXPECT_NE(host_->devices_->video_device, absl::nullopt);
+  EXPECT_FALSE(audio_device(/*stream_index=*/0u).has_value());
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
   const std::string label1 = host_->label_;
-  const std::string device_id1 = host_->devices_->video_device.value().id;
+  const std::string device_id1 = video_device(/*stream_index=*/0u).value().id;
   const base::UnguessableToken session_id1 =
-      host_->devices_->video_device.value().session_id();
+      host_->stream_devices_set_->stream_devices[0]
+          ->video_device.value()
+          .session_id();
 
   // Generate second stream.
   OpenVideoDeviceAndWaitForResult(kPageRequestId, device_id1);
@@ -677,12 +715,14 @@ TEST_F(MediaStreamDispatcherHostTest, GenerateStreamsDifferentRenderId) {
   GenerateStreamAndWaitForResult(kPageRequestId, controls);
 
   // Check the latest generated stream.
-  EXPECT_EQ(host_->devices_->audio_device, absl::nullopt);
-  EXPECT_NE(host_->devices_->video_device, absl::nullopt);
+  EXPECT_FALSE(audio_device(/*stream_index=*/0u).has_value());
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
   const std::string label1 = host_->label_;
-  const std::string device_id1 = host_->devices_->video_device.value().id;
+  const std::string device_id1 = video_device(/*stream_index=*/0u).value().id;
   const base::UnguessableToken session_id1 =
-      host_->devices_->video_device.value().session_id();
+      host_->stream_devices_set_->stream_devices[0]
+          ->video_device.value()
+          .session_id();
 
   // Generate second stream from another render frame.
   host_ = std::make_unique<MockMediaStreamDispatcherHost>(
@@ -696,12 +736,14 @@ TEST_F(MediaStreamDispatcherHostTest, GenerateStreamsDifferentRenderId) {
   GenerateStreamAndWaitForResult(kPageRequestId + 1, controls);
 
   // Check the latest generated stream.
-  EXPECT_EQ(host_->devices_->audio_device, absl::nullopt);
-  EXPECT_NE(host_->devices_->video_device, absl::nullopt);
+  EXPECT_FALSE(audio_device(/*stream_index=*/0u).has_value());
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
   const std::string label2 = host_->label_;
-  const std::string device_id2 = host_->devices_->video_device.value().id;
+  const std::string device_id2 = video_device(/*stream_index=*/0u).value().id;
   const base::UnguessableToken session_id2 =
-      host_->devices_->video_device.value().session_id();
+      host_->stream_devices_set_->stream_devices[0]
+          ->video_device.value()
+          .session_id();
   EXPECT_EQ(device_id1, device_id2);
   EXPECT_NE(session_id1, session_id2);
   EXPECT_NE(label1, label2);
@@ -721,7 +763,7 @@ TEST_F(MediaStreamDispatcherHostTest, WebContentsNotFocused) {
       OnStreamGenerationFailure(
           kPageRequestId,
           blink::mojom::MediaStreamRequestResult::FAILED_DUE_TO_SHUTDOWN));
-  host_->OnGenerateStream(kPageRequestId, controls, run_loop.QuitClosure());
+  host_->OnGenerateStreams(kPageRequestId, controls, run_loop.QuitClosure());
   run_loop.RunUntilIdle();
 }
 
@@ -737,7 +779,7 @@ TEST_F(MediaStreamDispatcherHostTest, WebContentsNotFocusedInBackgroundPage) {
                           base::Unretained(this)));
 
   base::RunLoop run_loop;
-  host_->OnGenerateStream(kPageRequestId, controls, run_loop.QuitClosure());
+  host_->OnGenerateStreams(kPageRequestId, controls, run_loop.QuitClosure());
 
   int expected_audio_array_size =
       (controls.audio.requested && !audio_device_descriptions_.empty()) ? 1 : 0;
@@ -749,8 +791,8 @@ TEST_F(MediaStreamDispatcherHostTest, WebContentsNotFocusedInBackgroundPage) {
       .Times(1);
 
   run_loop.Run();
-  EXPECT_NE(host_->devices_->audio_device, absl::nullopt);
-  EXPECT_NE(host_->devices_->video_device, absl::nullopt);
+  EXPECT_TRUE(audio_device(/*stream_index=*/0u).has_value());
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
 }
 
 TEST_F(MediaStreamDispatcherHostTest, WebContentsFocused) {
@@ -764,7 +806,7 @@ TEST_F(MediaStreamDispatcherHostTest, WebContentsFocused) {
                           base::Unretained(this)));
 
   base::RunLoop run_loop;
-  host_->OnGenerateStream(kPageRequestId, controls, run_loop.QuitClosure());
+  host_->OnGenerateStreams(kPageRequestId, controls, run_loop.QuitClosure());
   run_loop.RunUntilIdle();
 
   int expected_audio_array_size =
@@ -783,8 +825,8 @@ TEST_F(MediaStreamDispatcherHostTest, WebContentsFocused) {
   host_->OnWebContentsFocused();
 
   run_loop.Run();
-  EXPECT_NE(host_->devices_->audio_device, absl::nullopt);
-  EXPECT_NE(host_->devices_->video_device, absl::nullopt);
+  EXPECT_TRUE(audio_device(/*stream_index=*/0u).has_value());
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
 }
 
 // This test request two streams with video only without waiting for the first
@@ -804,9 +846,9 @@ TEST_F(MediaStreamDispatcherHostTest, GenerateStreamsWithoutWaiting) {
   }
   base::RunLoop run_loop1;
   base::RunLoop run_loop2;
-  host_->OnGenerateStream(kPageRequestId, controls, run_loop1.QuitClosure());
-  host_->OnGenerateStream(kPageRequestId + 1, controls,
-                          run_loop2.QuitClosure());
+  host_->OnGenerateStreams(kPageRequestId, controls, run_loop1.QuitClosure());
+  host_->OnGenerateStreams(kPageRequestId + 1, controls,
+                           run_loop2.QuitClosure());
 
   run_loop1.Run();
   run_loop2.Run();
@@ -829,7 +871,7 @@ TEST_F(MediaStreamDispatcherHostTest, GenerateStreamsWithSourceId) {
 
     SetupFakeUI(true);
     GenerateStreamAndWaitForResult(kPageRequestId, controls);
-    EXPECT_EQ(host_->devices_->audio_device.value().id, source_id);
+    EXPECT_EQ(audio_device(/*stream_index=*/0u).value().id, source_id);
   }
 
   for (const std::string& device_id : stub_video_device_ids_) {
@@ -840,7 +882,7 @@ TEST_F(MediaStreamDispatcherHostTest, GenerateStreamsWithSourceId) {
     controls.video.device_id = source_id;
 
     GenerateStreamAndWaitForResult(kPageRequestId, controls);
-    EXPECT_EQ(host_->devices_->video_device.value().id, source_id);
+    EXPECT_EQ(video_device(/*stream_index=*/0u).value().id, source_id);
   }
 }
 
@@ -884,17 +926,19 @@ TEST_F(MediaStreamDispatcherHostTest, StopDeviceInStream) {
   GenerateStreamAndWaitForResult(kPageRequestId, controls);
 
   std::string stream_request_label = host_->label_;
-  blink::MediaStreamDevice video_device = host_->devices_->video_device.value();
+  blink::MediaStreamDevice current_video_device =
+      video_device(/*stream_index=*/0u).value();
   ASSERT_EQ(
       1u, media_stream_manager_->GetDevicesOpenedByRequest(stream_request_label)
               .size());
 
   // Open the same device by Pepper.
-  OpenVideoDeviceAndWaitForResult(kPageRequestId, video_device.id);
+  OpenVideoDeviceAndWaitForResult(kPageRequestId, current_video_device.id);
   std::string open_device_request_label = host_->label_;
 
   // Stop the device in the MediaStream.
-  host_->OnStopStreamDevice(video_device.id, video_device.session_id());
+  host_->OnStopStreamDevice(current_video_device.id,
+                            current_video_device.session_id());
 
   EXPECT_EQ(
       0u, media_stream_manager_->GetDevicesOpenedByRequest(stream_request_label)
@@ -911,13 +955,15 @@ TEST_F(MediaStreamDispatcherHostTest, StopDeviceInStreamAndRestart) {
   GenerateStreamAndWaitForResult(kPageRequestId, controls);
 
   std::string request_label1 = host_->label_;
-  blink::MediaStreamDevice video_device = host_->devices_->video_device.value();
+  blink::MediaStreamDevice current_video_device =
+      video_device(/*stream_index=*/0u).value();
   // Expect that 1 audio and 1 video device has been opened.
   EXPECT_EQ(
       2u,
       media_stream_manager_->GetDevicesOpenedByRequest(request_label1).size());
 
-  host_->OnStopStreamDevice(video_device.id, video_device.session_id());
+  host_->OnStopStreamDevice(current_video_device.id,
+                            current_video_device.session_id());
   EXPECT_EQ(
       1u,
       media_stream_manager_->GetDevicesOpenedByRequest(request_label1).size());
@@ -944,22 +990,24 @@ TEST_F(MediaStreamDispatcherHostTest,
 
   SetupFakeUI(true);
   GenerateStreamAndWaitForResult(kPageRequestId, controls);
-  EXPECT_NE(host_->devices_->video_device, absl::nullopt);
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
 
   // Generate a second stream.
   EXPECT_CALL(*host_, OnStreamGenerationSuccess(kPageRequestId + 1, 0, 1));
 
   base::RunLoop run_loop1;
-  host_->OnGenerateStream(kPageRequestId + 1, controls,
-                          run_loop1.QuitClosure());
+  host_->OnGenerateStreams(kPageRequestId + 1, controls,
+                           run_loop1.QuitClosure());
 
   // Stop the video stream device from stream 1 while waiting for the
   // second stream to be generated.
-  host_->OnStopStreamDevice(host_->devices_->video_device.value().id,
-                            host_->devices_->video_device.value().session_id());
+  host_->OnStopStreamDevice(video_device(/*stream_index=*/0u).value().id,
+                            host_->stream_devices_set_->stream_devices[0]
+                                ->video_device.value()
+                                .session_id());
   run_loop1.Run();
 
-  EXPECT_NE(host_->devices_->video_device, absl::nullopt);
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
 }
 
 TEST_F(MediaStreamDispatcherHostTest, CancelPendingStreams) {
@@ -970,8 +1018,8 @@ TEST_F(MediaStreamDispatcherHostTest, CancelPendingStreams) {
   // Create multiple GenerateStream requests.
   size_t streams = 5;
   for (size_t i = 1; i <= streams; ++i) {
-    host_->OnGenerateStream(kPageRequestId + i, controls,
-                            run_loop.QuitClosure());
+    host_->OnGenerateStreams(kPageRequestId + i, controls,
+                             run_loop.QuitClosure());
   }
 
   media_stream_manager_->CancelAllRequests(kProcessId, kRenderId, kRequesterId);
@@ -1009,8 +1057,8 @@ TEST_F(MediaStreamDispatcherHostTest, CloseFromUI) {
 
   GenerateStreamAndWaitForResult(kPageRequestId, controls);
 
-  EXPECT_EQ(host_->devices_->audio_device, absl::nullopt);
-  EXPECT_NE(host_->devices_->video_device, absl::nullopt);
+  EXPECT_FALSE(audio_device(/*stream_index=*/0u).has_value());
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
 
   ASSERT_TRUE(close_callback);
   EXPECT_CALL(*host_, OnDeviceStopSuccess());
@@ -1024,8 +1072,8 @@ TEST_F(MediaStreamDispatcherHostTest, VideoDeviceUnplugged) {
   blink::StreamControls controls(true, true);
   SetupFakeUI(true);
   GenerateStreamAndWaitForResult(kPageRequestId, controls);
-  EXPECT_NE(host_->devices_->audio_device, absl::nullopt);
-  EXPECT_NE(host_->devices_->video_device, absl::nullopt);
+  EXPECT_TRUE(audio_device(/*stream_index=*/0u).has_value());
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
 
   stub_video_device_ids_.clear();
 
@@ -1046,15 +1094,21 @@ TEST_F(MediaStreamDispatcherHostTest, Salt) {
 
   // Generate first stream.
   GenerateStreamAndWaitForResult(kPageRequestId, controls);
-  EXPECT_EQ(host_->devices_->audio_device, absl::nullopt);
-  EXPECT_NE(host_->devices_->video_device, absl::nullopt);
+  EXPECT_FALSE(audio_device(/*stream_index=*/0u).has_value());
+  EXPECT_TRUE(video_device(/*stream_index=*/0u).has_value());
   const std::string label1 = host_->label_;
-  const std::string device_id1 = host_->devices_->video_device.value().id;
-  EXPECT_TRUE(host_->devices_->video_device.value().group_id.has_value());
-  const std::string group_id1 = *host_->devices_->video_device.value().group_id;
+  const std::string device_id1 = video_device(/*stream_index=*/0u).value().id;
+  EXPECT_TRUE(host_->stream_devices_set_->stream_devices[0]
+                  ->video_device.value()
+                  .group_id.has_value());
+  const std::string group_id1 = *host_->stream_devices_set_->stream_devices[0]
+                                     ->video_device.value()
+                                     .group_id;
   EXPECT_FALSE(group_id1.empty());
   const base::UnguessableToken session_id1 =
-      host_->devices_->video_device.value().session_id();
+      host_->stream_devices_set_->stream_devices[0]
+          ->video_device.value()
+          .session_id();
 
   // Generate second stream.
   OpenVideoDeviceAndWaitForResult(kPageRequestId, device_id1);
@@ -1098,4 +1152,6 @@ TEST_F(MediaStreamDispatcherHostTest, GetOpenDeviceWithoutFeatureFails) {
   loop.Run();
 }
 
+// TODO(crbug.com/1300883): Add test cases for multi stream generation.
+
 }  // namespace content
diff --git a/content/browser/renderer_host/media/media_stream_manager.cc b/content/browser/renderer_host/media/media_stream_manager.cc
index 4353e9647c68f93da8fd8ff8837109d1cf62a1a0..35fce1040801a8516487cd75637831aec32257f2 100644
--- a/content/browser/renderer_host/media/media_stream_manager.cc
+++ b/content/browser/renderer_host/media/media_stream_manager.cc
@@ -342,12 +342,12 @@ const char* RequestResultToString(
   return "INVALID";
 }
 
-std::string GetGenerateStreamLogString(int render_process_id,
-                                       int render_frame_id,
-                                       int requester_id,
-                                       int page_request_id) {
+std::string GetGenerateStreamsLogString(int render_process_id,
+                                        int render_frame_id,
+                                        int requester_id,
+                                        int page_request_id) {
   return base::StringPrintf(
-      "GenerateStream({render_process_id=%d}, {render_frame_id=%d}, "
+      "GenerateStreams({render_process_id=%d}, {render_frame_id=%d}, "
       "{requester_id=%d}, {page_request_id=%d})",
       render_process_id, render_frame_id, requester_id, page_request_id);
 }
@@ -817,7 +817,7 @@ class MediaStreamManager::DeviceRequest {
       std::move(generate_stream_cb)
           .Run(MediaStreamRequestResult::FAILED_DUE_TO_SHUTDOWN,
                /*label=*/std::string(),
-               /*stream_devices=*/nullptr,
+               /*stream_devices_set=*/nullptr,
                /*pan_tilt_zoom_allowed=*/false);
     }
 
@@ -872,7 +872,7 @@ class MediaStreamManager::DeviceRequest {
   // Currently it is only used by |DEVICE_ACCESS| type.
   MediaAccessRequestCallback media_access_request_cb;
 
-  GenerateStreamCallback generate_stream_cb;
+  GenerateStreamsCallback generate_stream_cb;
 
   // This callback is used by transferred MediaStreamTracks to access and clone
   // an existing open MediaStreamDevice (identified by its session_id). If the
@@ -1109,7 +1109,7 @@ std::string MediaStreamManager::MakeMediaAccessRequest(
   return label;
 }
 
-void MediaStreamManager::GenerateStream(
+void MediaStreamManager::GenerateStreams(
     int render_process_id,
     int render_frame_id,
     int requester_id,
@@ -1118,14 +1118,14 @@ void MediaStreamManager::GenerateStream(
     MediaDeviceSaltAndOrigin salt_and_origin,
     bool user_gesture,
     StreamSelectionInfoPtr audio_stream_selection_info_ptr,
-    GenerateStreamCallback generate_stream_cb,
+    GenerateStreamsCallback generate_stream_cb,
     DeviceStoppedCallback device_stopped_cb,
     DeviceChangedCallback device_changed_cb,
     DeviceRequestStateChangeCallback device_request_state_change_cb,
     DeviceCaptureHandleChangeCallback device_capture_handle_change_cb) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  SendLogMessage(GetGenerateStreamLogString(render_process_id, render_frame_id,
-                                            requester_id, page_request_id));
+  SendLogMessage(GetGenerateStreamsLogString(render_process_id, render_frame_id,
+                                             requester_id, page_request_id));
   std::unique_ptr<DeviceRequest> request = CreateDeviceRequest(
       render_process_id, render_frame_id, requester_id, page_request_id,
       controls, blink::MEDIA_GENERATE_STREAM, std::move(salt_and_origin),
@@ -1142,7 +1142,7 @@ void MediaStreamManager::GenerateStream(
     // as expected. Then we need to finish getUserMedia and let Javascript
     // access the result.
     if (std::move(generate_stream_test_callback_).Run(controls)) {
-      FinalizeGenerateStream(label, request_ptr);
+      FinalizeGenerateStreams(label, request_ptr);
     } else {
       FinalizeRequestFailed(label, request_ptr,
                             MediaStreamRequestResult::INVALID_STATE);
@@ -2196,13 +2196,13 @@ bool MediaStreamManager::FindExistingRequestedDevice(
   return false;
 }
 
-void MediaStreamManager::FinalizeGenerateStream(const std::string& label,
-                                                DeviceRequest* request) {
+void MediaStreamManager::FinalizeGenerateStreams(const std::string& label,
+                                                 DeviceRequest* request) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
   DCHECK(request);
   DCHECK(request->generate_stream_cb);
   SendLogMessage(
-      base::StringPrintf("FinalizeGenerateStream({label=%s}, {requester_id="
+      base::StringPrintf("FinalizeGenerateStreams({label=%s}, {requester_id="
                          "%d}, {request_type=%s})",
                          label.c_str(), request->requester_id,
                          RequestTypeToString(request->request_type())));
@@ -2211,6 +2211,10 @@ void MediaStreamManager::FinalizeGenerateStream(const std::string& label,
   // user denies mic/camera.
   SubscribeToPermissionController(label, request);
 
+  // TODO(crbug.com/1300883): Generalize to multiple streams.
+  blink::mojom::StreamDevicesSetPtr stream_devices_set =
+      blink::mojom::StreamDevicesSet::New();
+  stream_devices_set->stream_devices.emplace_back(request->devices.Clone());
   // It is safe to bind base::Unretained(this) because MediaStreamManager is
   // owned by BrowserMainLoop and so outlives the IO thread.
   // TODO(crbug.com/1314741): Avoid using PTZ permission checks for non-gUM
@@ -2226,7 +2230,7 @@ void MediaStreamManager::FinalizeGenerateStream(const std::string& label,
                      request->devices.video_device,
                      base::BindOnce(std::move(request->generate_stream_cb),
                                     MediaStreamRequestResult::OK, label,
-                                    request->devices.Clone())));
+                                    std::move(stream_devices_set))));
 }
 
 void MediaStreamManager::FinalizeGetOpenDevice(const std::string& label,
@@ -2342,7 +2346,8 @@ void MediaStreamManager::FinalizeRequestFailed(
     case blink::MEDIA_GENERATE_STREAM: {
       DCHECK(request->generate_stream_cb);
       std::move(request->generate_stream_cb)
-          .Run(result, std::string(), /*stream_devices=*/nullptr,
+          .Run(result, /*label=*/std::string(),
+               /*stream_devices_set=*/nullptr,
                /*pan_tilt_zoom_allowed=*/false);
       break;
     }
@@ -2362,7 +2367,8 @@ void MediaStreamManager::FinalizeRequestFailed(
     case blink::MEDIA_DEVICE_ACCESS: {
       DCHECK(request->media_access_request_cb);
       std::move(request->media_access_request_cb)
-          .Run(blink::mojom::StreamDevices(), std::move(request->ui_proxy));
+          .Run(/*stream_devices_set=*/blink::mojom::StreamDevicesSet(),
+               std::move(request->ui_proxy));
       break;
     }
     case blink::MEDIA_DEVICE_UPDATE: {
@@ -2467,8 +2473,11 @@ void MediaStreamManager::FinalizeMediaAccessRequest(
                          "%d}, {request_type=%s})",
                          label.c_str(), request->requester_id,
                          RequestTypeToString(request->request_type())));
+  blink::mojom::StreamDevicesSetPtr cloned_devices =
+      blink::mojom::StreamDevicesSet::New();
+  cloned_devices->stream_devices.emplace_back(devices.Clone());
   std::move(request->media_access_request_cb)
-      .Run(devices, std::move(request->ui_proxy));
+      .Run(std::move(*cloned_devices), std::move(request->ui_proxy));
 
   // Delete the request since it is done.
   DeleteRequest(label);
@@ -2596,7 +2605,7 @@ void MediaStreamManager::HandleRequestDone(const std::string& label,
       OnStreamStarted(label);
       break;
     case blink::MEDIA_GENERATE_STREAM: {
-      FinalizeGenerateStream(label, request);
+      FinalizeGenerateStreams(label, request);
       break;
     }
     case blink::MEDIA_GET_OPEN_DEVICE: {
@@ -3206,7 +3215,7 @@ void MediaStreamManager::SetCapturingLinkSecured(
   }
 }
 
-void MediaStreamManager::SetGenerateStreamCallbackForTesting(
+void MediaStreamManager::SetGenerateStreamsCallbackForTesting(
     GenerateStreamTestCallback test_callback) {
   generate_stream_test_callback_ = std::move(test_callback);
 }
diff --git a/content/browser/renderer_host/media/media_stream_manager.h b/content/browser/renderer_host/media/media_stream_manager.h
index fa7774ae73d88f12c277b98a2292d07b245a0f20..700c42dc425c914d105807260359f97fe5808734 100644
--- a/content/browser/renderer_host/media/media_stream_manager.h
+++ b/content/browser/renderer_host/media/media_stream_manager.h
@@ -90,15 +90,15 @@ class CONTENT_EXPORT MediaStreamManager
       public base::PowerThermalObserver {
  public:
   // Callback to deliver the result of a media access request.
-  using MediaAccessRequestCallback =
-      base::OnceCallback<void(const blink::mojom::StreamDevices& devices,
-                              std::unique_ptr<MediaStreamUIProxy> ui)>;
+  using MediaAccessRequestCallback = base::OnceCallback<void(
+      const blink::mojom::StreamDevicesSet& stream_devices_set,
+      std::unique_ptr<MediaStreamUIProxy> ui)>;
 
-  using GenerateStreamCallback =
-      base::OnceCallback<void(blink::mojom::MediaStreamRequestResult result,
-                              const std::string& label,
-                              blink::mojom::StreamDevicesPtr stream_devices,
-                              bool pan_tilt_zoom_allowed)>;
+  using GenerateStreamsCallback = base::OnceCallback<void(
+      blink::mojom::MediaStreamRequestResult result,
+      const std::string& label,
+      blink::mojom::StreamDevicesSetPtr stream_devices_set,
+      bool pan_tilt_zoom_allowed)>;
 
   using OpenDeviceCallback =
       base::OnceCallback<void(bool success,
@@ -203,7 +203,7 @@ class CONTENT_EXPORT MediaStreamManager
   // notify clients about request state changes.
   // TODO(crbug.com/1288839): Package device-related callbacks into a single
   // struct.
-  void GenerateStream(
+  void GenerateStreams(
       int render_process_id,
       int render_frame_id,
       int requester_id,
@@ -212,7 +212,7 @@ class CONTENT_EXPORT MediaStreamManager
       MediaDeviceSaltAndOrigin salt_and_origin,
       bool user_gesture,
       blink::mojom::StreamSelectionInfoPtr audio_stream_selection_info_ptr,
-      GenerateStreamCallback generate_stream_cb,
+      GenerateStreamsCallback generate_stream_cb,
       DeviceStoppedCallback device_stopped_cb,
       DeviceChangedCallback device_changed_cb,
       DeviceRequestStateChangeCallback device_request_state_change_cb,
@@ -408,7 +408,7 @@ class CONTENT_EXPORT MediaStreamManager
   void StopRemovedDevice(blink::mojom::MediaDeviceType type,
                          const blink::WebMediaDeviceInfo& media_device_info);
 
-  void SetGenerateStreamCallbackForTesting(
+  void SetGenerateStreamsCallbackForTesting(
       GenerateStreamTestCallback test_callback);
 
   // This method is called when all tracks are started.
@@ -574,7 +574,8 @@ class CONTENT_EXPORT MediaStreamManager
       blink::MediaStreamDevice* existing_device,
       MediaRequestState* existing_request_state) const;
 
-  void FinalizeGenerateStream(const std::string& label, DeviceRequest* request);
+  void FinalizeGenerateStreams(const std::string& label,
+                               DeviceRequest* request);
   void FinalizeGetOpenDevice(const std::string& label, DeviceRequest* request);
   void PanTiltZoomPermissionChecked(
       const std::string& label,
diff --git a/content/browser/renderer_host/media/media_stream_manager_unittest.cc b/content/browser/renderer_host/media/media_stream_manager_unittest.cc
index 0cd064916c66a3ffe1d93f75aed4d545865c1e20..89965452df24f46a243c2f9d0b5648655f5e4ef4 100644
--- a/content/browser/renderer_host/media/media_stream_manager_unittest.cc
+++ b/content/browser/renderer_host/media/media_stream_manager_unittest.cc
@@ -220,9 +220,10 @@ class MediaStreamManagerTest : public ::testing::Test {
   ~MediaStreamManagerTest() override { audio_manager_->Shutdown(); }
 
   MOCK_METHOD1(Response, void(int index));
-  void ResponseCallback(int index,
-                        const blink::mojom::StreamDevices& devices,
-                        std::unique_ptr<MediaStreamUIProxy> ui_proxy) {
+  void ResponseCallback(
+      int index,
+      const blink::mojom::StreamDevicesSet& stream_devices_set,
+      std::unique_ptr<MediaStreamUIProxy> ui_proxy) {
     Response(index);
     base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE,
                                                   run_loop_.QuitClosure());
@@ -265,8 +266,8 @@ class MediaStreamManagerTest : public ::testing::Test {
 
     blink::MediaStreamDevice video_device;
     blink::MediaStreamDevice audio_device;
-    MediaStreamManager::GenerateStreamCallback generate_stream_callback =
-        base::BindOnce(GenerateStreamCallback, &run_loop_, request_audio,
+    MediaStreamManager::GenerateStreamsCallback generate_stream_callback =
+        base::BindOnce(GenerateStreamsCallback, &run_loop_, request_audio,
                        true /* request_video */, &audio_device, &video_device);
     base::MockCallback<MediaStreamManager::DeviceStoppedCallback>
         stopped_callback;
@@ -293,7 +294,7 @@ class MediaStreamManagerTest : public ::testing::Test {
                   OnMediaRequestStateChanged(_, _, _, _, expected_type,
                                              MEDIA_REQUEST_STATE_DONE));
     }
-    media_stream_manager_->GenerateStream(
+    media_stream_manager_->GenerateStreams(
         render_process_id, render_frame_id, requester_id, page_request_id,
         controls, MediaDeviceSaltAndOrigin(), false /* user_gesture */,
         StreamSelectionInfo::New(
@@ -335,7 +336,7 @@ class MediaStreamManagerTest : public ::testing::Test {
     }
   }
 
-  static void GenerateStreamCallback(
+  static void GenerateStreamsCallback(
       base::RunLoop* wait_loop,
       bool request_audio,
       bool request_video,
@@ -343,20 +344,28 @@ class MediaStreamManagerTest : public ::testing::Test {
       blink::MediaStreamDevice* video_device,
       blink::mojom::MediaStreamRequestResult result,
       const std::string& label,
-      const blink::mojom::StreamDevicesPtr devices,
+      blink::mojom::StreamDevicesSetPtr stream_devices_set,
       bool pan_tilt_zoom_allowed) {
+    // TODO(crbug.com/1300883): Generalize to multiple streams.
+    DCHECK_EQ(stream_devices_set->stream_devices.size(), 1u);
     if (request_audio) {
-      ASSERT_TRUE(devices->audio_device.has_value());
-      *audio_device = devices->audio_device.value();
+      ASSERT_TRUE(
+          stream_devices_set->stream_devices[0]->audio_device.has_value());
+      *audio_device =
+          stream_devices_set->stream_devices[0]->audio_device.value();
     } else {
-      ASSERT_FALSE(devices->audio_device.has_value());
+      ASSERT_FALSE(
+          stream_devices_set->stream_devices[0]->audio_device.has_value());
     }
 
     if (request_video) {
-      ASSERT_TRUE(devices->video_device.has_value());
-      *video_device = devices->video_device.value();
+      ASSERT_TRUE(
+          stream_devices_set->stream_devices[0]->video_device.has_value());
+      *video_device =
+          stream_devices_set->stream_devices[0]->video_device.value();
     } else {
-      ASSERT_FALSE(devices->video_device.has_value());
+      ASSERT_FALSE(
+          stream_devices_set->stream_devices[0]->video_device.has_value());
     }
 
     wait_loop->Quit();
@@ -386,8 +395,8 @@ class MediaStreamManagerTest : public ::testing::Test {
     base::RunLoop run_loop;
     blink::MediaStreamDevice audio_device;
 
-    MediaStreamManager::GenerateStreamCallback generate_stream_callback =
-        base::BindOnce(GenerateStreamCallback, &run_loop, true, false,
+    MediaStreamManager::GenerateStreamsCallback generate_stream_callback =
+        base::BindOnce(GenerateStreamsCallback, &run_loop, true, false,
                        &audio_device, nullptr);
     MediaStreamManager::DeviceStoppedCallback stopped_callback;
     MediaStreamManager::DeviceChangedCallback changed_callback;
@@ -398,7 +407,7 @@ class MediaStreamManagerTest : public ::testing::Test {
 
     StreamSelectionInfoPtr info =
         StreamSelectionInfo::New(strategy, session_id);
-    media_stream_manager_->GenerateStream(
+    media_stream_manager_->GenerateStreams(
         render_process_id, render_frame_id, requester_id, page_request_id,
         controls, MediaDeviceSaltAndOrigin(), false /* user_gesture */,
         std::move(info), std::move(generate_stream_callback),
@@ -737,10 +746,10 @@ TEST_F(MediaStreamManagerTest, GetDisplayMediaRequestCallsUIProxy) {
   controls.video.stream_type =
       blink::mojom::MediaStreamType::DISPLAY_VIDEO_CAPTURE;
 
-  MediaStreamManager::GenerateStreamCallback generate_stream_callback =
+  MediaStreamManager::GenerateStreamsCallback generate_stream_callback =
       base::BindOnce([](blink::mojom::MediaStreamRequestResult result,
                         const std::string& label,
-                        blink::mojom::StreamDevicesPtr devices,
+                        blink::mojom::StreamDevicesSetPtr stream_devices_set,
                         bool pan_tilt_zoom_allowed) {});
   EXPECT_CALL(
       *media_observer_,
@@ -751,7 +760,7 @@ TEST_F(MediaStreamManagerTest, GetDisplayMediaRequestCallsUIProxy) {
   const int render_frame_id = 0;
   const int requester_id = 0;
   const int page_request_id = 0;
-  media_stream_manager_->GenerateStream(
+  media_stream_manager_->GenerateStreams(
       render_process_id, render_frame_id, requester_id, page_request_id,
       controls, MediaDeviceSaltAndOrigin(), false /* user_gesture */,
       StreamSelectionInfo::New(
@@ -785,8 +794,8 @@ TEST_F(MediaStreamManagerTest, DesktopCaptureDeviceStopped) {
   const int page_request_id = 1;
 
   blink::MediaStreamDevice video_device;
-  MediaStreamManager::GenerateStreamCallback generate_stream_callback =
-      base::BindOnce(GenerateStreamCallback, &run_loop_,
+  MediaStreamManager::GenerateStreamsCallback generate_stream_callback =
+      base::BindOnce(GenerateStreamsCallback, &run_loop_,
                      false /* request_audio */, true /* request_video */,
                      nullptr, &video_device);
   MediaStreamManager::DeviceStoppedCallback stopped_callback =
@@ -805,7 +814,7 @@ TEST_F(MediaStreamManagerTest, DesktopCaptureDeviceStopped) {
   MediaStreamManager::DeviceCaptureHandleChangeCallback
       capture_handle_change_callback;
 
-  media_stream_manager_->GenerateStream(
+  media_stream_manager_->GenerateStreams(
       render_process_id, render_frame_id, requester_id, page_request_id,
       controls, MediaDeviceSaltAndOrigin(), false /* user_gesture */,
       StreamSelectionInfo::New(
@@ -844,8 +853,8 @@ TEST_F(MediaStreamManagerTest, DesktopCaptureDeviceChanged) {
   const int page_request_id = 1;
 
   blink::MediaStreamDevice video_device;
-  MediaStreamManager::GenerateStreamCallback generate_stream_callback =
-      base::BindOnce(GenerateStreamCallback, &run_loop_,
+  MediaStreamManager::GenerateStreamsCallback generate_stream_callback =
+      base::BindOnce(GenerateStreamsCallback, &run_loop_,
                      false /* request_audio */, true /* request_video */,
                      nullptr, &video_device);
   MediaStreamManager::DeviceStoppedCallback stopped_callback;
@@ -872,7 +881,7 @@ TEST_F(MediaStreamManagerTest, DesktopCaptureDeviceChanged) {
   MediaStreamManager::DeviceCaptureHandleChangeCallback
       capture_handle_change_callback;
 
-  media_stream_manager_->GenerateStream(
+  media_stream_manager_->GenerateStreams(
       render_process_id, render_frame_id, requester_id, page_request_id,
       controls, MediaDeviceSaltAndOrigin(), false /* user_gesture */,
       StreamSelectionInfo::New(
@@ -989,4 +998,6 @@ TEST_F(MediaStreamManagerTest, GetMediaDeviceIDForHMAC) {
   base::RunLoop().RunUntilIdle();
 }
 
+// TODO(crbug.com/1300883): Add test cases for multi stream generation.
+
 }  // namespace content
diff --git a/content/browser/renderer_host/media/media_stream_ui_proxy.h b/content/browser/renderer_host/media/media_stream_ui_proxy.h
index 75ce3032e209c9531eaa9f02bf05549193d18884..0a261c77d819183a8cebaa1a911a3fd343c5d1da 100644
--- a/content/browser/renderer_host/media/media_stream_ui_proxy.h
+++ b/content/browser/renderer_host/media/media_stream_ui_proxy.h
@@ -170,7 +170,7 @@ class CONTENT_EXPORT FakeMediaStreamUIProxy : public MediaStreamUIProxy {
 
  private:
   // This is used for RequestAccess().
-  // TODO(crbug/1313021): Use blink::mojom::StreamDevices instead of
+  // TODO(crbug.com/1313021): Use blink::mojom::StreamDevices instead of
   // blink::MediaStreamDevices.
   blink::MediaStreamDevices devices_;
 
diff --git a/content/browser/speech/speech_recognition_manager_impl.cc b/content/browser/speech/speech_recognition_manager_impl.cc
index 4e4a2880bb3c0d515378a8ab176368a1f69fc5a3..63f4c6552fa66d76d9454fad14c38244f74845dc 100644
--- a/content/browser/speech/speech_recognition_manager_impl.cc
+++ b/content/browser/speech/speech_recognition_manager_impl.cc
@@ -295,7 +295,7 @@ void SpeechRecognitionManagerImpl::RecognitionAllowedCallback(int session_id,
 
 void SpeechRecognitionManagerImpl::MediaRequestPermissionCallback(
     int session_id,
-    const blink::mojom::StreamDevices& devices,
+    const blink::mojom::StreamDevicesSet& stream_devices_set,
     std::unique_ptr<MediaStreamUIProxy> stream_ui) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
@@ -303,8 +303,13 @@ void SpeechRecognitionManagerImpl::MediaRequestPermissionCallback(
   if (iter == sessions_.end())
     return;
 
+  // The SpeechRecognictionManager is not used with multiple streams
+  // which is only supported in combination with the getDisplayMediaSet API.
+  DCHECK_EQ(stream_devices_set.stream_devices.size(), 1u);
+  DCHECK(stream_devices_set.stream_devices[0]);
   blink::MediaStreamDevices devices_list =
-      blink::StreamDevicesToMediaStreamDevicesList(devices);
+      blink::StreamDevicesToMediaStreamDevicesList(
+          *stream_devices_set.stream_devices[0]);
   const bool is_allowed = !devices_list.empty();
   if (is_allowed) {
     // Copy the approved devices array to the context for UI indication.
diff --git a/content/browser/speech/speech_recognition_manager_impl.h b/content/browser/speech/speech_recognition_manager_impl.h
index 91affb4dd6839ccdd72c1b6311007c053aef3f30..50361b323e3068ff92cb4b56d3730b677c6e67c8 100644
--- a/content/browser/speech/speech_recognition_manager_impl.h
+++ b/content/browser/speech/speech_recognition_manager_impl.h
@@ -145,7 +145,7 @@ class CONTENT_EXPORT SpeechRecognitionManagerImpl
   // users deny the request.
   void MediaRequestPermissionCallback(
       int session_id,
-      const blink::mojom::StreamDevices& devices,
+      const blink::mojom::StreamDevicesSet& stream_devices_set,
       std::unique_ptr<MediaStreamUIProxy> stream_ui);
 
   // Entry point for pushing any external event into the session handling FSM.
diff --git a/content/browser/webrtc/webrtc_getusermedia_browsertest.cc b/content/browser/webrtc/webrtc_getusermedia_browsertest.cc
index 7e288021294bd248de81d9b6d84bf02204e81221..4cca073b79e9c5a1ff211b30e7edc8a2ffd6ee85 100644
--- a/content/browser/webrtc/webrtc_getusermedia_browsertest.cc
+++ b/content/browser/webrtc/webrtc_getusermedia_browsertest.cc
@@ -80,6 +80,9 @@ std::string GenerateGetUserMediaWithOptionalSourceID(
   return function_name + "({" + audio_constraint + video_constraint + "});";
 }
 
+// TODO(crbug.com/1327666): Bring back when
+// WebRtcGetUserMediaBrowserTest.DisableLocalEchoParameter is fixed.
+#if 0
 std::string GenerateGetUserMediaWithDisableLocalEcho(
     const std::string& function_name,
     const std::string& disable_local_echo) {
@@ -96,6 +99,7 @@ bool VerifyDisableLocalEcho(bool expect_value,
                             const blink::StreamControls& controls) {
   return expect_value == controls.disable_local_echo;
 }
+#endif
 
 }  // namespace
 
@@ -640,6 +644,10 @@ IN_PROC_BROWSER_TEST_F(WebRtcGetUserMediaBrowserTest,
   ExecuteJavascriptAndWaitForOk(call);
 }
 
+// TODO(crbug.com/1327666): Fix this test. It seems to be broken (no audio /
+// video tracks are requested; "uncaught (in promise) undefined)") and was false
+// positive before disabling.
+#if 0
 IN_PROC_BROWSER_TEST_F(WebRtcGetUserMediaBrowserTest,
                        DisableLocalEchoParameter) {
   base::CommandLine::ForCurrentProcess()->AppendSwitch(
@@ -652,21 +660,22 @@ IN_PROC_BROWSER_TEST_F(WebRtcGetUserMediaBrowserTest,
   MediaStreamManager* manager =
       BrowserMainLoop::GetInstance()->media_stream_manager();
 
-  manager->SetGenerateStreamCallbackForTesting(
+  manager->SetGenerateStreamsCallbackForTesting(
       base::BindOnce(&VerifyDisableLocalEcho, false));
   std::string call = GenerateGetUserMediaWithDisableLocalEcho(
       "getUserMediaAndExpectSuccess", "false");
   ExecuteJavascriptAndWaitForOk(call);
 
-  manager->SetGenerateStreamCallbackForTesting(
+  manager->SetGenerateStreamsCallbackForTesting(
       base::BindOnce(&VerifyDisableLocalEcho, true));
   call = GenerateGetUserMediaWithDisableLocalEcho(
       "getUserMediaAndExpectSuccess", "true");
   ExecuteJavascriptAndWaitForOk(call);
 
-  manager->SetGenerateStreamCallbackForTesting(
+  manager->SetGenerateStreamsCallbackForTesting(
       MediaStreamManager::GenerateStreamTestCallback());
 }
+#endif
 
 IN_PROC_BROWSER_TEST_F(WebRtcGetUserMediaBrowserTest, GetAudioSettingsDefault) {
   ASSERT_TRUE(embedded_test_server()->Start());
diff --git a/third_party/blink/common/mediastream/media_stream_request.cc b/third_party/blink/common/mediastream/media_stream_request.cc
index 6637eb603efb172a7c70aa8f727f1c1013d9b442..6f4537e4750a7efedf21e9f1e75fd1ecf87e3d03 100644
--- a/third_party/blink/common/mediastream/media_stream_request.cc
+++ b/third_party/blink/common/mediastream/media_stream_request.cc
@@ -144,8 +144,8 @@ bool MediaStreamDevice::IsSameDevice(
          session_id_ == other_device.session_id_;
 }
 
-// TODO(crbug/1313021): Remove this function and use blink::mojom::StreaDevices
-// directly everywhere.
+// TODO(crbug.com/1313021): Remove this function and use
+// blink::mojom::StreaDevices directly everywhere.
 blink::MediaStreamDevices StreamDevicesToMediaStreamDevicesList(
     const blink::mojom::StreamDevices& devices) {
   blink::MediaStreamDevices all_devices;
diff --git a/third_party/blink/public/mojom/mediastream/media_stream.mojom b/third_party/blink/public/mojom/mediastream/media_stream.mojom
index ea744980b8b392f4073e6d86b67905b8f51a122f..33cf4c3b7be7281809858d10ee0417ab9ba24957 100644
--- a/third_party/blink/public/mojom/mediastream/media_stream.mojom
+++ b/third_party/blink/public/mojom/mediastream/media_stream.mojom
@@ -142,12 +142,17 @@ interface MediaStreamDeviceObserver {
                               MediaStreamDevice device);
 };
 
-// Contains devices that are assigned to a specific stream.
+// Contains devices that are assigned to a specific stream. At least one of
+// audio_device / video_device must be set.
 struct StreamDevices {
   MediaStreamDevice? audio_device;
   MediaStreamDevice? video_device;
 };
 
+struct StreamDevicesSet {
+  array<StreamDevices> stream_devices;
+};
+
 // Per-frame browser-side interface that is used by the renderer process to
 // make media stream requests.
 interface MediaStreamDispatcherHost {
@@ -165,10 +170,18 @@ interface MediaStreamDispatcherHost {
   // finally, when it is SEARCH_BY_DEVICE_ID, an existing stream is used if the
   // device associated to the request already has an opened stream available, or
   // a new one otherwise.
-  GenerateStream(int32 request_id, StreamControls controls, bool user_gesture,
+  // The result callback provides:
+  // |result|: The overall result of the stream generation.
+  // |label|: The request label.
+  // |stream_devices|: A list of devices per stream. If |result| is not ok, this
+  // list may be null.
+  // |pan_tilt_zoom_allowed|: A flag indicating whether pan / tilt / zoom is
+  // allowed.
+  // TODO(crbug.com/1327958): Use expected<T,E> for the return values.
+  GenerateStreams(int32 request_id, StreamControls controls, bool user_gesture,
                  StreamSelectionInfo audio_stream_selection_info)
       => (MediaStreamRequestResult result, string label,
-         StreamDevices? stream_devices,
+         StreamDevicesSet? stream_devices,
          bool pan_tilt_zoom_allowed);
 
   // The |focus| bit is |true| if focus should be switched to
diff --git a/third_party/blink/renderer/modules/BUILD.gn b/third_party/blink/renderer/modules/BUILD.gn
index b479f44c7f1b339739291bb1de4c8a3b147c23d0..5e6a5dabc6e60435b868707d71fb4901c3d17033 100644
--- a/third_party/blink/renderer/modules/BUILD.gn
+++ b/third_party/blink/renderer/modules/BUILD.gn
@@ -500,6 +500,7 @@ source_set("unit_tests") {
     "mediastream/media_stream_constraints_util_video_content_test.cc",
     "mediastream/media_stream_constraints_util_video_device_test.cc",
     "mediastream/media_stream_device_observer_test.cc",
+    "mediastream/media_stream_set_test.cc",
     "mediastream/media_stream_track_impl_test.cc",
     "mediastream/media_stream_video_capturer_source_test.cc",
     "mediastream/media_stream_video_renderer_sink_test.cc",
diff --git a/third_party/blink/renderer/modules/mediastream/BUILD.gn b/third_party/blink/renderer/modules/mediastream/BUILD.gn
index a10775349f12282d2bd45dbf63b9023afff4adf5..19a9a56fc5581b712d49ab10e45cc1eb238378b4 100644
--- a/third_party/blink/renderer/modules/mediastream/BUILD.gn
+++ b/third_party/blink/renderer/modules/mediastream/BUILD.gn
@@ -55,6 +55,8 @@ blink_modules_sources("mediastream") {
     "media_stream_local_frame_wrapper.h",
     "media_stream_renderer_factory.cc",
     "media_stream_renderer_factory.h",
+    "media_stream_set.cc",
+    "media_stream_set.h",
     "media_stream_track.cc",
     "media_stream_track.h",
     "media_stream_track_content_hint.h",
diff --git a/third_party/blink/renderer/modules/mediastream/media_devices.cc b/third_party/blink/renderer/modules/mediastream/media_devices.cc
index a48737fffe26a72bcc482b0ef5358bd5fe5ce55d..55d888d1da2da288d341aab24fec42d331d82005 100644
--- a/third_party/blink/renderer/modules/mediastream/media_devices.cc
+++ b/third_party/blink/renderer/modules/mediastream/media_devices.cc
@@ -69,8 +69,10 @@ class PromiseResolverCallbacks final : public UserMediaRequest::Callbacks {
         on_success_follow_up_(std::move(on_success_follow_up)) {}
   ~PromiseResolverCallbacks() override = default;
 
-  void OnSuccess(MediaStream* stream) override {
-    DCHECK(stream);
+  void OnSuccess(const MediaStreamVector& streams) override {
+    // TODO(crbug.com/1300883): Generalize to multiple streams.
+    DCHECK_EQ(streams.size(), 1u);
+    MediaStream* stream = streams[0];
 
     MediaStreamTrack* video_track = nullptr;
 
diff --git a/third_party/blink/renderer/modules/mediastream/media_stream_set.cc b/third_party/blink/renderer/modules/mediastream/media_stream_set.cc
new file mode 100644
index 0000000000000000000000000000000000000000..e9b05b2925dccf8f8ce47d9b8de29847e1144ed3
--- /dev/null
+++ b/third_party/blink/renderer/modules/mediastream/media_stream_set.cc
@@ -0,0 +1,61 @@
+// Copyright 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/modules/mediastream/media_stream_set.h"
+
+#include "third_party/blink/renderer/modules/mediastream/media_stream.h"
+#include "third_party/blink/renderer/modules/modules_export.h"
+#include "third_party/blink/renderer/platform/heap/garbage_collected.h"
+#include "third_party/blink/renderer/platform/wtf/vector.h"
+
+namespace blink {
+
+MediaStreamSet* MediaStreamSet::Create(
+    ExecutionContext* context,
+    const MediaStreamDescriptorVector& stream_descriptors,
+    MediaStreamSetInitializedCallback callback) {
+  return MakeGarbageCollected<MediaStreamSet>(context, stream_descriptors,
+                                              std::move(callback));
+}
+
+MediaStreamSet::MediaStreamSet(
+    ExecutionContext* context,
+    const MediaStreamDescriptorVector& stream_descriptors,
+    MediaStreamSetInitializedCallback callback)
+    : ExecutionContextClient(context),
+      media_streams_to_initialize_count_(stream_descriptors.size()),
+      media_streams_initialized_callback_(std::move(callback)) {
+  if (!stream_descriptors.IsEmpty()) {
+    for (MediaStreamDescriptor* descriptor : stream_descriptors) {
+      MediaStream::Create(context, descriptor, /*track=*/nullptr,
+                          WTF::Bind(&MediaStreamSet::OnMediaStreamInitialized,
+                                    WrapPersistent(this)));
+    }
+  } else {
+    std::move(media_streams_initialized_callback_)
+        .Run(initialized_media_streams_);
+  }
+}
+
+// TODO(crbug.com/1300883): Clean up other streams if one stream capture
+// results in an error. This is only required for getDisplayMediaSet.
+// Currently existing functionality generates only one stream which is not
+// affected by this change.
+void MediaStreamSet::OnMediaStreamInitialized(
+    MediaStream* initialized_media_stream) {
+  DCHECK_LT(initialized_media_streams_.size(),
+            media_streams_to_initialize_count_);
+  initialized_media_streams_.push_back(initialized_media_stream);
+  if (initialized_media_streams_.size() == media_streams_to_initialize_count_) {
+    std::move(std::move(media_streams_initialized_callback_))
+        .Run(initialized_media_streams_);
+  }
+}
+
+void MediaStreamSet::Trace(Visitor* visitor) const {
+  visitor->Trace(initialized_media_streams_);
+  ExecutionContextClient::Trace(visitor);
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/mediastream/media_stream_set.h b/third_party/blink/renderer/modules/mediastream/media_stream_set.h
new file mode 100644
index 0000000000000000000000000000000000000000..40ae253c9f7a8be73ca0ed010b14eb5588a5f5c5
--- /dev/null
+++ b/third_party/blink/renderer/modules/mediastream/media_stream_set.h
@@ -0,0 +1,44 @@
+// Copyright 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_MEDIASTREAM_MEDIA_STREAM_SET_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_MEDIASTREAM_MEDIA_STREAM_SET_H_
+
+#include "third_party/blink/renderer/modules/mediastream/media_stream.h"
+#include "third_party/blink/renderer/modules/modules_export.h"
+#include "third_party/blink/renderer/platform/bindings/script_wrappable.h"
+#include "third_party/blink/renderer/platform/wtf/vector.h"
+
+namespace blink {
+
+using MediaStreamSetInitializedCallback =
+    base::OnceCallback<void(MediaStreamVector)>;
+
+class MODULES_EXPORT MediaStreamSet final
+    : public GarbageCollected<MediaStreamSet>,
+      public ExecutionContextClient {
+ public:
+  static MediaStreamSet* Create(
+      ExecutionContext* context,
+      const MediaStreamDescriptorVector& stream_descriptors,
+      MediaStreamSetInitializedCallback callback);
+
+  MediaStreamSet(ExecutionContext* context,
+                 const MediaStreamDescriptorVector& stream_descriptors,
+                 MediaStreamSetInitializedCallback callback);
+  virtual ~MediaStreamSet() = default;
+
+  void Trace(Visitor*) const override;
+
+ private:
+  void OnMediaStreamInitialized(MediaStream*);
+
+  const size_t media_streams_to_initialize_count_;
+  MediaStreamVector initialized_media_streams_;
+  MediaStreamSetInitializedCallback media_streams_initialized_callback_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_MEDIASTREAM_MEDIA_STREAM_SET_H_
diff --git a/third_party/blink/renderer/modules/mediastream/media_stream_set_test.cc b/third_party/blink/renderer/modules/mediastream/media_stream_set_test.cc
new file mode 100644
index 0000000000000000000000000000000000000000..73fc9934ab4abcd009e92ec4837be676403fe3ac
--- /dev/null
+++ b/third_party/blink/renderer/modules/mediastream/media_stream_set_test.cc
@@ -0,0 +1,143 @@
+// Copyright 2022 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "third_party/blink/renderer/modules/mediastream/media_stream_set.h"
+
+#include "base/run_loop.h"
+#include "base/test/bind.h"
+#include "base/test/gmock_callback_support.h"
+#include "testing/gtest/include/gtest/gtest.h"
+#include "third_party/blink/public/platform/modules/mediastream/web_platform_media_stream_source.h"
+#include "third_party/blink/public/platform/scheduler/test/renderer_scheduler_test_support.h"
+#include "third_party/blink/public/web/modules/mediastream/media_stream_video_source.h"
+#include "third_party/blink/public/web/web_heap.h"
+#include "third_party/blink/renderer/bindings/core/v8/v8_binding_for_testing.h"
+#include "third_party/blink/renderer/platform/bindings/exception_state.h"
+#include "third_party/blink/renderer/platform/heap/garbage_collected.h"
+#include "third_party/blink/renderer/platform/testing/io_task_runner_testing_platform_support.h"
+
+using testing::_;
+
+namespace blink {
+
+namespace {
+
+class MockLocalMediaStreamVideoSource : public blink::MediaStreamVideoSource {
+ public:
+  MockLocalMediaStreamVideoSource()
+      : blink::MediaStreamVideoSource(
+            blink::scheduler::GetSingleThreadTaskRunnerForTesting()) {}
+
+ private:
+  base::WeakPtr<MediaStreamVideoSource> GetWeakPtr() const override {
+    return weak_factory_.GetWeakPtr();
+  }
+
+  void StartSourceImpl(VideoCaptureDeliverFrameCB frame_callback,
+                       EncodedVideoFrameCB encoded_frame_callback) override {}
+
+  void StopSourceImpl() override {}
+
+  base::WeakPtrFactory<MockLocalMediaStreamVideoSource> weak_factory_{this};
+};
+
+class MediaStreamSetTest : public testing::Test {
+ public:
+  MediaStreamSetTest() = default;
+  ~MediaStreamSetTest() override { WebHeap::CollectAllGarbageForTesting(); }
+};
+
+TEST_F(MediaStreamSetTest, SingleMediaStreamInitialized) {
+  V8TestingScope v8_scope;
+  Member<MediaStreamSource> test_video_source =
+      MakeGarbageCollected<MediaStreamSource>(
+          "test_source_1", MediaStreamSource::StreamType::kTypeVideo,
+          "test_source_1", false,
+          std::make_unique<MockLocalMediaStreamVideoSource>());
+  MediaStreamSourceVector audio_source_vector = {};
+  MediaStreamSourceVector video_source_vector = {test_video_source};
+  Member<MediaStreamDescriptor> descriptor =
+      MakeGarbageCollected<MediaStreamDescriptor>(audio_source_vector,
+                                                  video_source_vector);
+  MediaStreamDescriptorVector descriptors = {descriptor};
+  base::RunLoop run_loop;
+  Member<MediaStreamSet> media_stream_set =
+      MakeGarbageCollected<MediaStreamSet>(
+          v8_scope.GetExecutionContext(), descriptors,
+          base::BindLambdaForTesting([&run_loop](MediaStreamVector streams) {
+            ASSERT_EQ(streams.size(), 1u);
+            run_loop.Quit();
+          }));
+  DCHECK(media_stream_set);
+  run_loop.Run();
+}
+
+TEST_F(MediaStreamSetTest, MultipleMediaStreamsInitialized) {
+  V8TestingScope v8_scope;
+  Member<MediaStreamSource> test_video_source =
+      MakeGarbageCollected<MediaStreamSource>(
+          "test_source_1", MediaStreamSource::StreamType::kTypeVideo,
+          "test_source_1", false,
+          std::make_unique<MockLocalMediaStreamVideoSource>());
+  MediaStreamSourceVector audio_source_vector = {};
+  MediaStreamSourceVector video_source_vector = {test_video_source};
+  Member<MediaStreamDescriptor> descriptor =
+      MakeGarbageCollected<MediaStreamDescriptor>(audio_source_vector,
+                                                  video_source_vector);
+  MediaStreamDescriptorVector descriptors = {descriptor, descriptor, descriptor,
+                                             descriptor};
+  base::RunLoop run_loop;
+  Member<MediaStreamSet> media_stream_set =
+      MakeGarbageCollected<MediaStreamSet>(
+          v8_scope.GetExecutionContext(), descriptors,
+          base::BindLambdaForTesting([&run_loop](MediaStreamVector streams) {
+            ASSERT_EQ(streams.size(), 4u);
+            run_loop.Quit();
+          }));
+  DCHECK(media_stream_set);
+  run_loop.Run();
+}
+
+TEST_F(MediaStreamSetTest, NoTracksInStream) {
+  V8TestingScope v8_scope;
+  MediaStreamSourceVector audio_source_vector = {};
+  MediaStreamSourceVector video_source_vector = {};
+  Member<MediaStreamDescriptor> descriptor =
+      MakeGarbageCollected<MediaStreamDescriptor>(audio_source_vector,
+                                                  video_source_vector);
+  MediaStreamDescriptorVector descriptors = {descriptor};
+  base::RunLoop run_loop;
+  Member<MediaStreamSet> media_stream_set =
+      MakeGarbageCollected<MediaStreamSet>(
+          v8_scope.GetExecutionContext(), descriptors,
+          base::BindLambdaForTesting([&run_loop](MediaStreamVector streams) {
+            ASSERT_EQ(streams.size(), 1u);
+            ASSERT_EQ(streams[0]->getVideoTracks().size(), 0u);
+            ASSERT_EQ(streams[0]->getAudioTracks().size(), 0u);
+            run_loop.Quit();
+          }));
+  DCHECK(media_stream_set);
+  run_loop.Run();
+}
+
+TEST_F(MediaStreamSetTest, NoMediaStreamInitialized) {
+  V8TestingScope v8_scope;
+  MediaStreamSourceVector audio_source_vector = {};
+  MediaStreamSourceVector video_source_vector = {};
+  MediaStreamDescriptorVector descriptors;
+  base::RunLoop run_loop;
+  Member<MediaStreamSet> media_stream_set =
+      MakeGarbageCollected<MediaStreamSet>(
+          v8_scope.GetExecutionContext(), descriptors,
+          base::BindLambdaForTesting([&run_loop](MediaStreamVector streams) {
+            ASSERT_TRUE(streams.IsEmpty());
+            run_loop.Quit();
+          }));
+  DCHECK(media_stream_set);
+  run_loop.Run();
+}
+
+}  // namespace
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/mediastream/media_stream_track.cc b/third_party/blink/renderer/modules/mediastream/media_stream_track.cc
index d33abf894d4f9180a12f31ad51951aab33310665..92c833b9a5cf29710a66d544c0724fc80337f68f 100644
--- a/third_party/blink/renderer/modules/mediastream/media_stream_track.cc
+++ b/third_party/blink/renderer/modules/mediastream/media_stream_track.cc
@@ -19,7 +19,7 @@ class GetOpenDeviceRequestCallbacks final : public UserMediaRequest::Callbacks {
  public:
   ~GetOpenDeviceRequestCallbacks() override = default;
 
-  void OnSuccess(MediaStream* stream) override {}
+  void OnSuccess(const MediaStreamVector& streams) override {}
   void OnError(ScriptWrappable* callback_this_value,
                const V8MediaStreamError* error) override {}
 };
diff --git a/third_party/blink/renderer/modules/mediastream/mock_mojo_media_stream_dispatcher_host.cc b/third_party/blink/renderer/modules/mediastream/mock_mojo_media_stream_dispatcher_host.cc
index c5e5f0719531513eaf694ba60b3b813a5be03da7..82dc307c1b9a5d18534c9fb8129e67050d9cc22d 100644
--- a/third_party/blink/renderer/modules/mediastream/mock_mojo_media_stream_dispatcher_host.cc
+++ b/third_party/blink/renderer/modules/mediastream/mock_mojo_media_stream_dispatcher_host.cc
@@ -17,12 +17,12 @@ MockMojoMediaStreamDispatcherHost::CreatePendingRemoteAndBind() {
   return receiver_.BindNewPipeAndPassRemote();
 }
 
-void MockMojoMediaStreamDispatcherHost::GenerateStream(
+void MockMojoMediaStreamDispatcherHost::GenerateStreams(
     int32_t request_id,
     const StreamControls& controls,
     bool user_gesture,
     mojom::blink::StreamSelectionInfoPtr audio_stream_selection_info_ptr,
-    GenerateStreamCallback callback) {
+    GenerateStreamsCallback callback) {
   request_id_ = request_id;
   ++request_stream_counter_;
   stream_devices_ = blink::mojom::blink::StreamDevices();
@@ -52,9 +52,13 @@ void MockMojoMediaStreamDispatcherHost::GenerateStream(
   if (do_not_run_cb_) {
     generate_stream_cb_ = std::move(callback);
   } else {
+    // TODO(crbug.com/1300883): Generalize to multiple streams.
+    blink::mojom::blink::StreamDevicesSetPtr stream_devices_set =
+        blink::mojom::blink::StreamDevicesSet::New();
+    stream_devices_set->stream_devices.emplace_back(stream_devices_.Clone());
     std::move(callback).Run(mojom::blink::MediaStreamRequestResult::OK,
                             String("dummy") + String::Number(request_id_),
-                            stream_devices_.Clone(),
+                            std::move(stream_devices_set),
                             /*pan_tilt_zoom_allowed=*/false);
   }
 }
diff --git a/third_party/blink/renderer/modules/mediastream/mock_mojo_media_stream_dispatcher_host.h b/third_party/blink/renderer/modules/mediastream/mock_mojo_media_stream_dispatcher_host.h
index 25b41b1240b9820a5fb8aacbe46d427b76ee9506..28139f6299c40f3337276ec6cd63a062aa007e85 100644
--- a/third_party/blink/renderer/modules/mediastream/mock_mojo_media_stream_dispatcher_host.h
+++ b/third_party/blink/renderer/modules/mediastream/mock_mojo_media_stream_dispatcher_host.h
@@ -30,12 +30,12 @@ class MockMojoMediaStreamDispatcherHost
   mojo::PendingRemote<mojom::blink::MediaStreamDispatcherHost>
   CreatePendingRemoteAndBind();
 
-  void GenerateStream(
+  void GenerateStreams(
       int32_t request_id,
       const StreamControls& controls,
       bool user_gesture,
       mojom::blink::StreamSelectionInfoPtr audio_stream_selection_info_ptr,
-      GenerateStreamCallback callback) override;
+      GenerateStreamsCallback callback) override;
   void CancelRequest(int32_t request_id) override;
   void StopStreamDevice(
       const WTF::String& device_id,
@@ -84,7 +84,7 @@ class MockMojoMediaStreamDispatcherHost
   base::UnguessableToken session_id_ = base::UnguessableToken::Create();
   bool do_not_run_cb_ = false;
   blink::mojom::blink::StreamDevices stream_devices_;
-  GenerateStreamCallback generate_stream_cb_;
+  GenerateStreamsCallback generate_stream_cb_;
   mojo::Receiver<mojom::blink::MediaStreamDispatcherHost> receiver_{this};
 };
 
diff --git a/third_party/blink/renderer/modules/mediastream/navigator_media_stream.cc b/third_party/blink/renderer/modules/mediastream/navigator_media_stream.cc
index 3938e2941f52a673554e3399ebae0a5b7df8324d..cdce230ee5c7fb18888087aa7e10bad445931c34 100644
--- a/third_party/blink/renderer/modules/mediastream/navigator_media_stream.cc
+++ b/third_party/blink/renderer/modules/mediastream/navigator_media_stream.cc
@@ -58,9 +58,11 @@ class V8Callbacks final : public blink::UserMediaRequest::Callbacks {
     UserMediaRequest::Callbacks::Trace(visitor);
   }
 
-  void OnSuccess(MediaStream* stream) override {
-    success_callback_->InvokeAndReportException(nullptr, stream);
+  void OnSuccess(const MediaStreamVector& streams) override {
+    DCHECK_EQ(streams.size(), 1u);
+    success_callback_->InvokeAndReportException(nullptr, streams[0]);
   }
+
   void OnError(ScriptWrappable* callback_this_value,
                const V8MediaStreamError* error) override {
     error_callback_->InvokeAndReportException(callback_this_value, error);
diff --git a/third_party/blink/renderer/modules/mediastream/user_media_client_test.cc b/third_party/blink/renderer/modules/mediastream/user_media_client_test.cc
index 53e1b73e10f0f98d8c3ae55ecaa9958b346aa100..6efdb3b9742c093689031ec11cd9d31279324f56 100644
--- a/third_party/blink/renderer/modules/mediastream/user_media_client_test.cc
+++ b/third_party/blink/renderer/modules/mediastream/user_media_client_test.cc
@@ -421,9 +421,11 @@ class UserMediaProcessorUnderTest : public UserMediaProcessor {
     return source;
   }
 
-  void GetUserMediaRequestSucceeded(MediaStreamDescriptor* descriptor,
+  void GetUserMediaRequestSucceeded(MediaStreamDescriptorVector* descriptors,
                                     UserMediaRequest* request_info) override {
-    last_generated_descriptor_ = descriptor;
+    // TODO(crbug.com/1300883): Generalize to multiple streams.
+    DCHECK_EQ(descriptors->size(), 1u);
+    last_generated_descriptor_ = (*descriptors)[0];
     *state_ = kRequestSucceeded;
   }
 
diff --git a/third_party/blink/renderer/modules/mediastream/user_media_processor.cc b/third_party/blink/renderer/modules/mediastream/user_media_processor.cc
index 802d9f0985c53f1ea2ee12ffd4be2ff2ce68204f..7021c7cb4956208ab2ba79331a7327de55e0c354 100644
--- a/third_party/blink/renderer/modules/mediastream/user_media_processor.cc
+++ b/third_party/blink/renderer/modules/mediastream/user_media_processor.cc
@@ -14,6 +14,7 @@
 #include "base/containers/contains.h"
 #include "base/location.h"
 #include "base/logging.h"
+#include "base/ranges/algorithm.h"
 #include "base/stl_util.h"
 #include "base/strings/stringprintf.h"
 #include "base/task/single_thread_task_runner.h"
@@ -24,6 +25,7 @@
 #include "third_party/blink/public/common/browser_interface_broker_proxy.h"
 #include "third_party/blink/public/common/mediastream/media_stream_controls.h"
 #include "third_party/blink/public/common/mediastream/media_stream_request.h"
+#include "third_party/blink/public/mojom/mediastream/media_stream.mojom-blink.h"
 #include "third_party/blink/public/platform/modules/mediastream/web_media_stream_source.h"
 #include "third_party/blink/public/platform/modules/mediastream/web_media_stream_track.h"
 #include "third_party/blink/public/platform/modules/webrtc/webrtc_logging.h"
@@ -385,8 +387,9 @@ class UserMediaProcessor::RequestInfo final
     video_capture_settings_ = settings;
   }
 
-  void SetDevices(mojom::blink::StreamDevicesPtr stream_devices) {
-    stream_devices_ = std::move(stream_devices);
+  void SetDevices(mojom::blink::StreamDevicesSetPtr stream_devices_set) {
+    stream_devices_set_.stream_devices =
+        std::move(stream_devices_set->stream_devices);
   }
 
   void AddNativeVideoFormats(const String& device_id,
@@ -402,25 +405,37 @@ class UserMediaProcessor::RequestInfo final
     return &it->value;
   }
 
-  void InitializeWebStream(const String& label,
-                           const MediaStreamComponentVector& audios,
-                           const MediaStreamComponentVector& videos) {
-    descriptor_ =
-        MakeGarbageCollected<MediaStreamDescriptor>(label, audios, videos);
+  void InitializeWebStreams(
+      const String& label,
+      const MediaStreamsComponentsVector& streams_components) {
+    DCHECK(!streams_components.IsEmpty());
+
+    // TODO(crbug.com/1313021): Refactor descriptors to make the assumption of
+    // at most one audio and video track explicit.
+    descriptors_ = MakeGarbageCollected<MediaStreamDescriptorVector>();
+    for (const MediaStreamComponents* tracks : streams_components) {
+      descriptors_->push_back(MakeGarbageCollected<MediaStreamDescriptor>(
+          label,
+          !tracks->audio_track_
+              ? MediaStreamComponentVector()
+              : MediaStreamComponentVector{tracks->audio_track_},
+          !tracks->video_track_
+              ? MediaStreamComponentVector()
+              : MediaStreamComponentVector{tracks->video_track_}));
+    }
   }
 
-  const mojom::blink::StreamDevices& devices() const {
-    return *stream_devices_;
+  bool CanStartTracks() const {
+    return video_formats_map_.size() == count_video_devices();
   }
 
-  bool CanStartTracks() const {
-    return video_formats_map_.size() ==
-           (stream_devices_->video_device.has_value() ? 1u : 0u);
+  MediaStreamDescriptorVector* descriptors() {
+    DCHECK(descriptors_);
+    return descriptors_;
   }
 
-  MediaStreamDescriptor* descriptor() {
-    DCHECK(descriptor_);
-    return descriptor_;
+  const mojom::blink::StreamDevicesSet& devices_set() const {
+    return stream_devices_set_;
   }
 
   StreamControls* stream_controls() { return &stream_controls_; }
@@ -436,7 +451,7 @@ class UserMediaProcessor::RequestInfo final
 
   void Trace(Visitor* visitor) const {
     visitor->Trace(request_);
-    visitor->Trace(descriptor_);
+    visitor->Trace(descriptors_);
     visitor->Trace(sources_);
   }
 
@@ -450,13 +465,15 @@ class UserMediaProcessor::RequestInfo final
   // that |this| might be deleted when the function returns.
   void CheckAllTracksStarted();
 
+  size_t count_video_devices() const;
+
   Member<UserMediaRequest> request_;
   State state_ = State::kNotSentForGeneration;
   blink::AudioCaptureSettings audio_capture_settings_;
   bool is_audio_content_capture_ = false;
   blink::VideoCaptureSettings video_capture_settings_;
   bool is_video_content_capture_ = false;
-  Member<MediaStreamDescriptor> descriptor_;
+  Member<MediaStreamDescriptorVector> descriptors_;
   StreamControls stream_controls_;
   ResourcesReady ready_callback_;
   MediaStreamRequestResult request_result_ = MediaStreamRequestResult::OK;
@@ -465,7 +482,7 @@ class UserMediaProcessor::RequestInfo final
   HeapVector<Member<MediaStreamSource>> sources_;
   Vector<blink::WebPlatformMediaStreamSource*> sources_waiting_for_callback_;
   HashMap<String, Vector<media::VideoCaptureFormat>> video_formats_map_;
-  mojom::blink::StreamDevicesPtr stream_devices_;
+  mojom::blink::StreamDevicesSet stream_devices_set_;
   bool pan_tilt_zoom_allowed_ = false;
 };
 
@@ -556,6 +573,15 @@ void UserMediaProcessor::RequestInfo::CheckAllTracksStarted() {
   }
 }
 
+size_t UserMediaProcessor::RequestInfo::count_video_devices() const {
+  return base::ranges::count_if(
+      stream_devices_set_.stream_devices.begin(),
+      stream_devices_set_.stream_devices.end(),
+      [](const mojom::blink::StreamDevicesPtr& stream_devices) {
+        return stream_devices->video_device.has_value();
+      });
+}
+
 void UserMediaProcessor::RequestInfo::OnAudioSourceStarted(
     blink::WebPlatformMediaStreamSource* source,
     MediaStreamRequestResult result,
@@ -959,7 +985,7 @@ void UserMediaProcessor::GenerateStreamForCurrentRequestInfo(
                   current_request_info_->request_id()));
   } else {
     // The browser replies to this request by invoking OnStreamGenerated().
-    GetMediaStreamDispatcherHost()->GenerateStream(
+    GetMediaStreamDispatcherHost()->GenerateStreams(
         current_request_info_->request_id(),
         *current_request_info_->stream_controls(),
         current_request_info_->is_processing_user_gesture(),
@@ -1009,7 +1035,11 @@ void UserMediaProcessor::GotOpenDevice(
     NOTREACHED();
   }
 
-  OnStreamGenerated(request_id, result, response->label, std::move(devices),
+  mojom::blink::StreamDevicesSetPtr stream_devices_set =
+      mojom::blink::StreamDevicesSet::New();
+  stream_devices_set->stream_devices.emplace_back(std::move(devices));
+  OnStreamGenerated(request_id, result, response->label,
+                    std::move(stream_devices_set),
                     response->pan_tilt_zoom_allowed);
 }
 
@@ -1017,35 +1047,47 @@ void UserMediaProcessor::OnStreamGenerated(
     int32_t request_id,
     MediaStreamRequestResult result,
     const String& label,
-    mojom::blink::StreamDevicesPtr stream_devices,
+    mojom::blink::StreamDevicesSetPtr stream_devices_set,
     bool pan_tilt_zoom_allowed) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
 
   if (result != MediaStreamRequestResult::OK) {
+    DCHECK(!stream_devices_set);
     OnStreamGenerationFailed(request_id, result);
     return;
   }
 
-  DCHECK(stream_devices);
+  // TODO(crbug.com/1300883): Generalize to multiple streams.
+  DCHECK(stream_devices_set && stream_devices_set->stream_devices.size() == 1u);
   if (!IsCurrentRequestInfo(request_id)) {
     // This can happen if the request is canceled or the frame reloads while
     // MediaStreamDispatcherHost is processing the request.
     SendLogMessage(base::StringPrintf(
         "OnStreamGenerated([request_id=%d]) => (ERROR: invalid request ID)",
         request_id));
-    OnStreamGeneratedForCancelledRequest(*stream_devices);
+    for (const mojom::blink::StreamDevicesPtr& stream_devices :
+         stream_devices_set->stream_devices) {
+      OnStreamGeneratedForCancelledRequest(*stream_devices);
+    }
     return;
   }
 
   current_request_info_->set_state(RequestInfo::State::kGenerated);
   current_request_info_->set_pan_tilt_zoom_allowed(pan_tilt_zoom_allowed);
 
-  MaybeLogStreamDevice(request_id, label, stream_devices->audio_device);
-  MaybeLogStreamDevice(request_id, label, stream_devices->video_device);
+  for (const mojom::blink::StreamDevicesPtr& stream_devices :
+       stream_devices_set->stream_devices) {
+    MaybeLogStreamDevice(request_id, label, stream_devices->audio_device);
+    MaybeLogStreamDevice(request_id, label, stream_devices->video_device);
+  }
 
-  current_request_info_->SetDevices(stream_devices->Clone());
+  current_request_info_->SetDevices(stream_devices_set->Clone());
 
-  if (!stream_devices->video_device.has_value()) {
+  if (base::ranges::none_of(
+          stream_devices_set->stream_devices,
+          [](const mojom::blink::StreamDevicesPtr& stream_devices) {
+            return stream_devices->video_device.has_value();
+          })) {
     StartTracks(label);
     return;
   }
@@ -1053,20 +1095,23 @@ void UserMediaProcessor::OnStreamGenerated(
   if (current_request_info_->is_video_content_capture()) {
     media::VideoCaptureFormat format =
         current_request_info_->video_capture_settings().Format();
-    if (stream_devices->video_device.has_value()) {
-      String video_device_id(stream_devices->video_device.value().id.data());
-      current_request_info_->AddNativeVideoFormats(
-          video_device_id,
-          {media::VideoCaptureFormat(GetScreenSize(), format.frame_rate,
-                                     format.pixel_format)});
+    for (const mojom::blink::StreamDevicesPtr& stream_devices :
+         stream_devices_set->stream_devices) {
+      if (stream_devices->video_device.has_value()) {
+        String video_device_id(stream_devices->video_device.value().id.data());
+        current_request_info_->AddNativeVideoFormats(
+            video_device_id,
+            {media::VideoCaptureFormat(GetScreenSize(), format.frame_rate,
+                                       format.pixel_format)});
+      }
     }
     StartTracks(label);
     return;
   }
 
-  if (stream_devices->video_device.has_value()) {
+  if (stream_devices_set->stream_devices[0]->video_device.has_value()) {
     const MediaStreamDevice& video_device =
-        stream_devices->video_device.value();
+        stream_devices_set->stream_devices[0]->video_device.value();
     SendLogMessage(base::StringPrintf(
         "OnStreamGenerated({request_id=%d}, {label=%s}, {device=[id: %s, "
         "name: %s]}) => (Requesting video device formats)",
@@ -1522,99 +1567,94 @@ void UserMediaProcessor::StartTracks(const String& label) {
   SendLogMessage(base::StringPrintf("StartTracks({request_id=%d}, {label=%s})",
                                     current_request_info_->request_id(),
                                     label.Utf8().c_str()));
-  WTF::Vector<blink::MediaStreamDevice> audio_devices;
-  if (current_request_info_->devices().audio_device.has_value()) {
-    audio_devices.push_back(
-        current_request_info_->devices().audio_device.value());
-  }
-  WTF::Vector<blink::MediaStreamDevice> video_devices;
-  if (current_request_info_->devices().video_device.has_value()) {
-    video_devices.push_back(
-        current_request_info_->devices().video_device.value());
-  }
-  if (auto* media_stream_device_observer = GetMediaStreamDeviceObserver()) {
-    // TODO(crbug/1313021): audio_devices and video_devices only contain one
-    // device. Change the AddStream interface to make this explicit.
-    media_stream_device_observer->AddStream(
-        blink::WebString(label), ToStdVector(audio_devices),
-        ToStdVector(video_devices),
-        WTF::BindRepeating(&UserMediaProcessor::OnDeviceStopped,
-                           WrapWeakPersistent(this)),
-        WTF::BindRepeating(&UserMediaProcessor::OnDeviceChanged,
-                           WrapWeakPersistent(this)),
-        WTF::BindRepeating(&UserMediaProcessor::OnDeviceRequestStateChange,
-                           WrapWeakPersistent(this)),
-        WTF::BindRepeating(&UserMediaProcessor::OnDeviceCaptureHandleChange,
-                           WrapWeakPersistent(this)));
-  }
-
-  HeapVector<Member<MediaStreamComponent>> audio_tracks(audio_devices.size());
-  CreateAudioTracks(audio_devices, &audio_tracks);
-
-  HeapVector<Member<MediaStreamComponent>> video_tracks(video_devices.size());
-  CreateVideoTracks(video_devices, &video_tracks);
 
-  String blink_id = label;
-  current_request_info_->InitializeWebStream(blink_id, audio_tracks,
-                                             video_tracks);
+  WebMediaStreamDeviceObserver* media_stream_device_observer =
+      GetMediaStreamDeviceObserver();
+  MediaStreamsComponentsVector stream_components_set;
+  for (const mojom::blink::StreamDevicesPtr& stream_devices :
+       current_request_info_->devices_set().stream_devices) {
+    if (media_stream_device_observer) {
+      // TODO(crbug.com/1300883): Change the interface to use a single optional
+      // MediaStream instead of a vector.
+      MediaStreamDevices audio_devices;
+      if (stream_devices->audio_device)
+        audio_devices.emplace_back(*stream_devices->audio_device);
+      MediaStreamDevices video_devices;
+      if (stream_devices->video_device)
+        video_devices.emplace_back(*stream_devices->video_device);
+      // TODO(crbug.com/1327960): Introduce interface to replace the four
+      // separate callbacks.
+      media_stream_device_observer->AddStream(
+          WebString(label), audio_devices, video_devices,
+          WTF::BindRepeating(&UserMediaProcessor::OnDeviceStopped,
+                             WrapWeakPersistent(this)),
+          WTF::BindRepeating(&UserMediaProcessor::OnDeviceChanged,
+                             WrapWeakPersistent(this)),
+          WTF::BindRepeating(&UserMediaProcessor::OnDeviceRequestStateChange,
+                             WrapWeakPersistent(this)),
+          WTF::BindRepeating(&UserMediaProcessor::OnDeviceCaptureHandleChange,
+                             WrapWeakPersistent(this)));
+    }
+    stream_components_set.push_back(MakeGarbageCollected<MediaStreamComponents>(
+        CreateAudioTrack(stream_devices->audio_device),
+        CreateVideoTrack(stream_devices->video_device)));
+  }
 
+  String blink_id = label;
+  current_request_info_->InitializeWebStreams(blink_id, stream_components_set);
   // Wait for the tracks to be started successfully or to fail.
   current_request_info_->CallbackOnTracksStarted(
       WTF::Bind(&UserMediaProcessor::OnCreateNativeTracksCompleted,
                 WrapWeakPersistent(this), label));
 }
 
-void UserMediaProcessor::CreateVideoTracks(
-    const Vector<MediaStreamDevice>& devices,
-    HeapVector<Member<MediaStreamComponent>>* components) {
+MediaStreamComponent* UserMediaProcessor::CreateVideoTrack(
+    const absl::optional<MediaStreamDevice>& device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   DCHECK(current_request_info_);
-  DCHECK_EQ(devices.size(), components->size());
-  SendLogMessage(base::StringPrintf("UMP::CreateVideoTracks({request_id=%d})",
-                                    current_request_info_->request_id()));
-
-  for (WTF::wtf_size_t i = 0; i < devices.size(); ++i) {
-    MediaStreamSource* source = InitializeVideoSourceObject(devices[i]);
-    (*components)[i] = current_request_info_->CreateAndStartVideoTrack(source);
-  }
+  if (!device)
+    return nullptr;
+  MediaStreamSource* source = InitializeVideoSourceObject(*device);
+  return current_request_info_->CreateAndStartVideoTrack(source);
 }
 
-void UserMediaProcessor::CreateAudioTracks(
-    const Vector<MediaStreamDevice>& devices,
-    HeapVector<Member<MediaStreamComponent>>* components) {
+MediaStreamComponent* UserMediaProcessor::CreateAudioTrack(
+    const absl::optional<MediaStreamDevice>& device) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   DCHECK(current_request_info_);
-  DCHECK_EQ(devices.size(), components->size());
-
-  Vector<MediaStreamDevice> overridden_audio_devices = devices;
+  if (!device)
+    return nullptr;
+  MediaStreamDevice overriden_audio_device = *device;
   bool render_to_associated_sink =
       current_request_info_->audio_capture_settings().HasValue() &&
       current_request_info_->audio_capture_settings()
           .render_to_associated_sink();
+
   SendLogMessage(
-      base::StringPrintf("CreateAudioTracks({render_to_associated_sink=%d})",
+      base::StringPrintf("CreateAudioTrack({render_to_associated_sink=%d})",
                          render_to_associated_sink));
+
   if (!render_to_associated_sink) {
     // If the GetUserMedia request did not explicitly set the constraint
     // kMediaStreamRenderToAssociatedSink, the output device id must
     // be removed.
-    for (auto& device : overridden_audio_devices)
-      device.matched_output_device_id.reset();
+    overriden_audio_device.matched_output_device_id.reset();
   }
 
-  for (WTF::wtf_size_t i = 0; i < overridden_audio_devices.size(); ++i) {
-    bool is_pending = false;
-    MediaStreamSource* source =
-        InitializeAudioSourceObject(overridden_audio_devices[i], &is_pending);
-    (*components)[i] = MakeGarbageCollected<MediaStreamComponent>(
-        source,
-        std::make_unique<MediaStreamAudioTrack>(true /* is_local_track */));
-    current_request_info_->StartAudioTrack((*components)[i], is_pending);
-    // At this point the source has started, and its audio parameters have been
-    // set. Thus, all audio processing properties are known and can be surfaced
-    // to |source|.
-    SurfaceAudioProcessingSettings(source);
-  }
+  bool is_pending = false;
+  MediaStreamSource* source =
+      InitializeAudioSourceObject(overriden_audio_device, &is_pending);
+  Member<MediaStreamComponent> component =
+      MakeGarbageCollected<MediaStreamComponent>(
+          source,
+          std::make_unique<MediaStreamAudioTrack>(true /* is_local_track */));
+  current_request_info_->StartAudioTrack(component, is_pending);
+
+  // At this point the source has started, and its audio parameters have been
+  // set. Thus, all audio processing properties are known and can be surfaced
+  // to |source|.
+  SurfaceAudioProcessingSettings(source);
+  return component;
 }
 
 void UserMediaProcessor::OnCreateNativeTracksCompleted(
@@ -1627,24 +1667,27 @@ void UserMediaProcessor::OnCreateNativeTracksCompleted(
       "UMP::OnCreateNativeTracksCompleted({request_id=%d}, {label=%s})",
       request_info->request_id(), label.Utf8().c_str()));
   if (result == MediaStreamRequestResult::OK) {
-    GetUserMediaRequestSucceeded(request_info->descriptor(),
+    GetUserMediaRequestSucceeded(request_info->descriptors(),
                                  request_info->request());
     GetMediaStreamDispatcherHost()->OnStreamStarted(label);
   } else {
     GetUserMediaRequestFailed(result, constraint_name);
 
-    for (auto web_track : request_info->descriptor()->AudioComponents()) {
-      MediaStreamTrackPlatform* track =
-          MediaStreamTrackPlatform::GetTrack(WebMediaStreamTrack(web_track));
-      if (track)
-        track->Stop();
-    }
+    for (const MediaStreamDescriptor* descriptor :
+         *request_info->descriptors()) {
+      for (auto web_track : descriptor->AudioComponents()) {
+        MediaStreamTrackPlatform* track =
+            MediaStreamTrackPlatform::GetTrack(WebMediaStreamTrack(web_track));
+        if (track)
+          track->Stop();
+      }
 
-    for (auto web_track : request_info->descriptor()->VideoComponents()) {
-      MediaStreamTrackPlatform* track =
-          MediaStreamTrackPlatform::GetTrack(WebMediaStreamTrack(web_track));
-      if (track)
-        track->Stop();
+      for (auto web_track : descriptor->VideoComponents()) {
+        MediaStreamTrackPlatform* track =
+            MediaStreamTrackPlatform::GetTrack(WebMediaStreamTrack(web_track));
+        if (track)
+          track->Stop();
+      }
     }
   }
 
@@ -1652,7 +1695,7 @@ void UserMediaProcessor::OnCreateNativeTracksCompleted(
 }
 
 void UserMediaProcessor::GetUserMediaRequestSucceeded(
-    MediaStreamDescriptor* descriptor,
+    MediaStreamDescriptorVector* descriptors,
     UserMediaRequest* user_media_request) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   DCHECK(IsCurrentRequestInfo(user_media_request));
@@ -1668,13 +1711,13 @@ void UserMediaProcessor::GetUserMediaRequestSucceeded(
       FROM_HERE,
       WTF::Bind(&UserMediaProcessor::DelayedGetUserMediaRequestSucceeded,
                 WrapWeakPersistent(this), current_request_info_->request_id(),
-                WrapPersistent(descriptor),
+                WrapPersistent(descriptors),
                 WrapPersistent(user_media_request)));
 }
 
 void UserMediaProcessor::DelayedGetUserMediaRequestSucceeded(
     int32_t request_id,
-    MediaStreamDescriptor* component,
+    MediaStreamDescriptorVector* components,
     UserMediaRequest* user_media_request) {
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   SendLogMessage(base::StringPrintf(
@@ -1683,7 +1726,7 @@ void UserMediaProcessor::DelayedGetUserMediaRequestSucceeded(
       MediaStreamRequestResultToString(MediaStreamRequestResult::OK)));
   blink::LogUserMediaRequestResult(MediaStreamRequestResult::OK);
   DeleteUserMediaRequest(user_media_request);
-  user_media_request->Succeed(component);
+  user_media_request->Succeed(*components);
 }
 
 void UserMediaProcessor::GetUserMediaRequestFailed(
diff --git a/third_party/blink/renderer/modules/mediastream/user_media_processor.h b/third_party/blink/renderer/modules/mediastream/user_media_processor.h
index 7ef98a00e272f35c7e8d22606f13343a00a385a0..e8cbdb87515213b9704622ed5209d25e5fb2f777 100644
--- a/third_party/blink/renderer/modules/mediastream/user_media_processor.h
+++ b/third_party/blink/renderer/modules/mediastream/user_media_processor.h
@@ -21,6 +21,7 @@
 #include "third_party/blink/renderer/modules/mediastream/user_media_request.h"
 #include "third_party/blink/renderer/modules/modules_export.h"
 #include "third_party/blink/renderer/platform/heap/collection_support/heap_vector.h"
+#include "third_party/blink/renderer/platform/mediastream/media_stream_descriptor.h"
 #include "third_party/blink/renderer/platform/mojo/heap_mojo_remote.h"
 #include "third_party/blink/renderer/platform/mojo/heap_mojo_wrapper_mode.h"
 #include "third_party/blink/renderer/platform/wtf/text/wtf_string.h"
@@ -114,7 +115,7 @@ class MODULES_EXPORT UserMediaProcessor
   // test requesting local media streams. The function notifies WebKit that the
   // |request| have completed.
   virtual void GetUserMediaRequestSucceeded(
-      MediaStreamDescriptor* descriptor,
+      MediaStreamDescriptorVector* descriptors,
       UserMediaRequest* user_media_request);
   virtual void GetUserMediaRequestFailed(
       blink::mojom::blink::MediaStreamRequestResult result,
@@ -154,7 +155,7 @@ class MODULES_EXPORT UserMediaProcessor
   void OnStreamGenerated(int32_t request_id,
                          blink::mojom::blink::MediaStreamRequestResult result,
                          const String& label,
-                         blink::mojom::blink::StreamDevicesPtr stream_devices,
+                         mojom::blink::StreamDevicesSetPtr streams_devices_set,
                          bool pan_tilt_zoom_allowed);
 
   void GotAllVideoInputFormatsForDevice(
@@ -173,7 +174,7 @@ class MODULES_EXPORT UserMediaProcessor
   bool IsCurrentRequestInfo(UserMediaRequest* user_media_request) const;
   void DelayedGetUserMediaRequestSucceeded(
       int32_t request_id,
-      MediaStreamDescriptor* descriptor,
+      MediaStreamDescriptorVector* descriptors,
       UserMediaRequest* user_media_request);
   void DelayedGetUserMediaRequestFailed(
       int32_t request_id,
@@ -195,11 +196,11 @@ class MODULES_EXPORT UserMediaProcessor
 
   void StartTracks(const String& label);
 
-  void CreateVideoTracks(const Vector<blink::MediaStreamDevice>& devices,
-                         HeapVector<Member<MediaStreamComponent>>* components);
+  blink::MediaStreamComponent* CreateVideoTrack(
+      const absl::optional<blink::MediaStreamDevice>& device);
 
-  void CreateAudioTracks(const Vector<blink::MediaStreamDevice>& devices,
-                         HeapVector<Member<MediaStreamComponent>>* components);
+  blink::MediaStreamComponent* CreateAudioTrack(
+      const absl::optional<blink::MediaStreamDevice>& device);
 
   // Callback function triggered when all native versions of the
   // underlying media sources and tracks have been created and started.
diff --git a/third_party/blink/renderer/modules/mediastream/user_media_request.cc b/third_party/blink/renderer/modules/mediastream/user_media_request.cc
index 2d72577698f0bd2e25ec115f74b8fc7c94902970..2e7fd8ef70ac0e1ed72a265befe77b851c7ef8cd 100644
--- a/third_party/blink/renderer/modules/mediastream/user_media_request.cc
+++ b/third_party/blink/renderer/modules/mediastream/user_media_request.cc
@@ -50,6 +50,7 @@
 #include "third_party/blink/renderer/modules/mediastream/media_constraints_impl.h"
 #include "third_party/blink/renderer/modules/mediastream/media_error_state.h"
 #include "third_party/blink/renderer/modules/mediastream/media_stream.h"
+#include "third_party/blink/renderer/modules/mediastream/media_stream_set.h"
 #include "third_party/blink/renderer/modules/mediastream/overconstrained_error.h"
 #include "third_party/blink/renderer/modules/mediastream/transferred_media_stream_track.h"
 #include "third_party/blink/renderer/modules/mediastream/user_media_controller.h"
@@ -501,35 +502,52 @@ void UserMediaRequest::Start() {
     controller_->RequestUserMedia(this);
 }
 
-void UserMediaRequest::Succeed(MediaStreamDescriptor* stream_descriptor) {
+void UserMediaRequest::Succeed(
+    const MediaStreamDescriptorVector& streams_descriptors) {
   DCHECK(!is_resolved_);
+  DCHECK(transferred_track_ == nullptr || streams_descriptors.size() == 1u);
   if (!GetExecutionContext())
     return;
 
-  MediaStream::Create(GetExecutionContext(), stream_descriptor,
-                      transferred_track_,
-                      WTF::Bind(&UserMediaRequest::OnMediaStreamInitialized,
-                                WrapPersistent(this)));
+  if (transferred_track_) {
+    MediaStream::Create(GetExecutionContext(), streams_descriptors[0],
+                        transferred_track_,
+                        WTF::Bind(&UserMediaRequest::OnMediaStreamInitialized,
+                                  WrapPersistent(this)));
+  } else {
+    MediaStreamSet::Create(
+        GetExecutionContext(), streams_descriptors,
+        WTF::Bind(&UserMediaRequest::OnMediaStreamsInitialized,
+                  WrapPersistent(this)));
+  }
 }
 
 void UserMediaRequest::OnMediaStreamInitialized(MediaStream* stream) {
-  DCHECK(!is_resolved_);
-
-  MediaStreamTrackVector audio_tracks = stream->getAudioTracks();
-  for (const auto& audio_track : audio_tracks)
-    audio_track->SetConstraints(audio_);
+  OnMediaStreamsInitialized({stream});
+}
 
-  MediaStreamTrackVector video_tracks = stream->getVideoTracks();
-  for (const auto& video_track : video_tracks)
-    video_track->SetConstraints(video_);
+void UserMediaRequest::OnMediaStreamsInitialized(MediaStreamVector streams) {
+  DCHECK(!is_resolved_);
 
-  RecordIdentifiabilityMetric(surface_, GetExecutionContext(),
-                              IdentifiabilityBenignStringToken(g_empty_string));
-  if (auto* window = GetWindow()) {
-    PeerConnectionTracker::From(*window).TrackGetUserMediaSuccess(this, stream);
+  for (const Member<MediaStream>& stream : streams) {
+    MediaStreamTrackVector audio_tracks = stream->getAudioTracks();
+    for (const auto& audio_track : audio_tracks)
+      audio_track->SetConstraints(audio_);
+
+    MediaStreamTrackVector video_tracks = stream->getVideoTracks();
+    for (const auto& video_track : video_tracks)
+      video_track->SetConstraints(video_);
+
+    RecordIdentifiabilityMetric(
+        surface_, GetExecutionContext(),
+        IdentifiabilityBenignStringToken(g_empty_string));
+    if (auto* window = GetWindow()) {
+      PeerConnectionTracker::From(*window).TrackGetUserMediaSuccess(this,
+                                                                    stream);
+    }
   }
   // After this call, the execution context may be invalid.
-  callbacks_->OnSuccess(stream);
+  callbacks_->OnSuccess(streams);
   is_resolved_ = true;
 }
 
diff --git a/third_party/blink/renderer/modules/mediastream/user_media_request.h b/third_party/blink/renderer/modules/mediastream/user_media_request.h
index 44dcf9b08556697b87e58556c861427f57fa5872..8d7d0747ba9d26ee1b9e1999cde8658c2632275e 100644
--- a/third_party/blink/renderer/modules/mediastream/user_media_request.h
+++ b/third_party/blink/renderer/modules/mediastream/user_media_request.h
@@ -34,6 +34,7 @@
 #include "third_party/blink/public/common/privacy_budget/identifiable_surface.h"
 #include "third_party/blink/renderer/bindings/modules/v8/v8_typedefs.h"
 #include "third_party/blink/renderer/core/execution_context/execution_context_lifecycle_observer.h"
+#include "third_party/blink/renderer/modules/mediastream/media_stream.h"
 #include "third_party/blink/renderer/modules/modules_export.h"
 #include "third_party/blink/renderer/platform/mediastream/media_constraints.h"
 #include "third_party/blink/renderer/platform/mediastream/media_stream_source.h"
@@ -43,9 +44,7 @@ namespace blink {
 
 class LocalDOMWindow;
 class MediaErrorState;
-class MediaStream;
 class MediaStreamConstraints;
-class MediaStreamDescriptor;
 class ScriptWrappable;
 class TransferredMediaStreamTrack;
 class UserMediaController;
@@ -77,7 +76,7 @@ class MODULES_EXPORT UserMediaRequest final
    public:
     virtual ~Callbacks() = default;
 
-    virtual void OnSuccess(MediaStream*) = 0;
+    virtual void OnSuccess(const MediaStreamVector&) = 0;
     virtual void OnError(ScriptWrappable* callback_this_value,
                          const V8MediaStreamError* error) = 0;
 
@@ -113,8 +112,9 @@ class MODULES_EXPORT UserMediaRequest final
 
   void Start();
 
-  void Succeed(MediaStreamDescriptor*);
+  void Succeed(const MediaStreamDescriptorVector& streams);
   void OnMediaStreamInitialized(MediaStream* stream);
+  void OnMediaStreamsInitialized(MediaStreamVector streams);
   void FailConstraint(const String& constraint_name, const String& message);
   void Fail(Error name, const String& message);
 
diff --git a/third_party/blink/renderer/modules/peerconnection/peer_connection_tracker.cc b/third_party/blink/renderer/modules/peerconnection/peer_connection_tracker.cc
index 133c95337bcee5624f37e6282001aabc2e88ae13..30e5b6bfb365a738d72fdab31fee0d657cbc26c7 100644
--- a/third_party/blink/renderer/modules/peerconnection/peer_connection_tracker.cc
+++ b/third_party/blink/renderer/modules/peerconnection/peer_connection_tracker.cc
@@ -1137,7 +1137,7 @@ void PeerConnectionTracker::TrackGetUserMedia(
 
 void PeerConnectionTracker::TrackGetUserMediaSuccess(
     UserMediaRequest* user_media_request,
-    MediaStream* stream) {
+    const MediaStream* stream) {
   DCHECK_CALLED_ON_VALID_THREAD(main_thread_);
 
   // Serialize audio and video track information (id and label) or an
diff --git a/third_party/blink/renderer/modules/peerconnection/peer_connection_tracker.h b/third_party/blink/renderer/modules/peerconnection/peer_connection_tracker.h
index 29ea5d1beefc8fa5462be481dbe5f0d76bac500d..477dfc3a5384643f46804966888afa549769d39d 100644
--- a/third_party/blink/renderer/modules/peerconnection/peer_connection_tracker.h
+++ b/third_party/blink/renderer/modules/peerconnection/peer_connection_tracker.h
@@ -242,7 +242,7 @@ class MODULES_EXPORT PeerConnectionTracker
   virtual void TrackGetUserMedia(UserMediaRequest* user_media_request);
   // Sends an update when getUserMedia resolveѕ with a stream.
   virtual void TrackGetUserMediaSuccess(UserMediaRequest* user_media_request,
-                                        MediaStream* stream);
+                                        const MediaStream* stream);
   // Sends an update when getUserMedia fails with an error.
   virtual void TrackGetUserMediaFailure(UserMediaRequest* user_media_request,
                                         const String& error,
diff --git a/third_party/blink/renderer/platform/mediastream/media_stream_component.cc b/third_party/blink/renderer/platform/mediastream/media_stream_component.cc
index fe99dafcf4e7d81b3a20ce1b8a87ce5cf3ffaa2c..d149a99ce68ecff29bc4acd4eb741a9234022046 100644
--- a/third_party/blink/renderer/platform/mediastream/media_stream_component.cc
+++ b/third_party/blink/renderer/platform/mediastream/media_stream_component.cc
@@ -197,4 +197,15 @@ void MediaStreamComponent::Trace(Visitor* visitor) const {
   visitor->Trace(source_);
 }
 
+MediaStreamComponents::MediaStreamComponents(MediaStreamComponent* audio_track,
+                                             MediaStreamComponent* video_track)
+    : audio_track_(audio_track), video_track_(video_track) {
+  DCHECK(audio_track_ || video_track_);
+}
+
+void MediaStreamComponents::Trace(Visitor* visitor) const {
+  visitor->Trace(audio_track_);
+  visitor->Trace(video_track_);
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/platform/mediastream/media_stream_component.h b/third_party/blink/renderer/platform/mediastream/media_stream_component.h
index bbd3f54dce8f2a61814790f8aa4714911f02c4d1..572b972a96b67a81254e20212e765dfbfd9922ad 100644
--- a/third_party/blink/renderer/platform/mediastream/media_stream_component.h
+++ b/third_party/blink/renderer/platform/mediastream/media_stream_component.h
@@ -168,7 +168,21 @@ class PLATFORM_EXPORT MediaStreamComponent final
   WebLocalFrame* creation_frame_ = nullptr;
 };
 
-typedef HeapVector<Member<MediaStreamComponent>> MediaStreamComponentVector;
+class PLATFORM_EXPORT MediaStreamComponents final
+    : public GarbageCollected<MediaStreamComponents> {
+ public:
+  // At least one of audio_track / video_track must be non-null.
+  MediaStreamComponents(MediaStreamComponent* audio_track,
+                        MediaStreamComponent* video_track);
+
+  void Trace(Visitor*) const;
+
+  Member<MediaStreamComponent> audio_track_;
+  Member<MediaStreamComponent> video_track_;
+};
+
+using MediaStreamComponentVector = HeapVector<Member<MediaStreamComponent>>;
+using MediaStreamsComponentsVector = HeapVector<Member<MediaStreamComponents>>;
 
 }  // namespace blink
 
